import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as s,f as e}from"./app-0mkQjek1.js";const t={},i=e(`<h1 id="阿里一面" tabindex="-1"><a class="header-anchor" href="#阿里一面" aria-hidden="true">#</a> 阿里一面</h1><h2 id="_1-自我介绍" tabindex="-1"><a class="header-anchor" href="#_1-自我介绍" aria-hidden="true">#</a> 1. 自我介绍</h2><h2 id="_2-青岛项目技术设计-详细介绍" tabindex="-1"><a class="header-anchor" href="#_2-青岛项目技术设计-详细介绍" aria-hidden="true">#</a> 2. 青岛项目技术设计，详细介绍</h2><ol><li>前处理三维静态模型</li><li>前处理二维轨道预览</li><li>后处理仿真三维场景</li></ol><h2 id="_3-参数和3d模型的渲染的影响" tabindex="-1"><a class="header-anchor" href="#_3-参数和3d模型的渲染的影响" aria-hidden="true">#</a> 3. 参数和3d模型的渲染的影响</h2><p>这个需要模型配合。</p><h2 id="_4-三维模型渲染慢的解决方案" tabindex="-1"><a class="header-anchor" href="#_4-三维模型渲染慢的解决方案" aria-hidden="true">#</a> 4. 三维模型渲染慢的解决方案</h2><ol><li>前后端请求</li><li>压缩三维模型</li><li>异步加载模型</li><li>转化成 Blob 格式的文件，存在 IndexedDB 中，就可以解决免去二次加载时网络请求的时间。（localforage.setItem()）</li><li>模型预加载</li><li>过渡loading</li></ol><h2 id="_5-umi屏幕适配原理" tabindex="-1"><a class="header-anchor" href="#_5-umi屏幕适配原理" aria-hidden="true">#</a> 5. umi屏幕适配原理</h2><ol><li>将根节点字体设置为屏幕宽度的十分之一</li><li>利用插件postcss将css的px转化为rem</li></ol><h2 id="_6-其他适配方案" tabindex="-1"><a class="header-anchor" href="#_6-其他适配方案" aria-hidden="true">#</a> 6. 其他适配方案</h2><ol><li>百分比布局</li><li>rem布局</li><li>媒体查询+改根节点字体/改静态页面</li><li>flex弹性布局</li><li>流式布局，宽度百分比，高度px</li></ol><h2 id="_7-echart渲染大数据做了哪些优化" tabindex="-1"><a class="header-anchor" href="#_7-echart渲染大数据做了哪些优化" aria-hidden="true">#</a> 7. echart渲染大数据做了哪些优化</h2><ol><li>提供dataZoom，进行数据区域放缩，类似于范围条，只显示所选范围的</li><li>线条曲线提供sampling，过滤数据，比如只取过滤点的最大值、平均值等，还有个lttb算法（最大程度保证数据趋势和极值）</li><li>提供appendData进行分片加载数据和增量渲染（渲染新数据时不会清除已经渲染的）</li></ol><h2 id="_8-渲染大数据表格方案" tabindex="-1"><a class="header-anchor" href="#_8-渲染大数据表格方案" aria-hidden="true">#</a> 8. 渲染大数据表格方案</h2><ol><li>echart提供的一些api优化，如sampling中的lttb算法过滤数据，dataZoom区域显示，appendData进行分片加载数据和增量渲染。</li><li>懒加载表图，只显示屏幕上的。</li><li>web worker，将计算密集型或者高延迟的渲染任务交给worker线程，主线程负责ui交互。</li><li>虚拟列表：只渲染可视区域的内容的列表。当鼠标滚动时，再渲染下一波内容，即虚拟列表中的dom元素始终是指定数目的。 <ol><li>计算当前可见区域起始数据的 startIndex</li><li>计算当前可见区域结束数据的 endIndex</li><li>计算当前可见区域的数据，并渲染到页面中</li><li>计算 startIndex 对应的数据在整个列表中的偏移位置 startOffset，并设置到列表上</li></ol></li></ol><h2 id="_9-fiber架构-完整" tabindex="-1"><a class="header-anchor" href="#_9-fiber架构-完整" aria-hidden="true">#</a> 9. fiber架构（完整）</h2><p>背景：传统dom tree遍历子节点需要进行递归，会占用大量js调用栈。而是用fiber tree遍历链表，不用递归。（递归调用，执行栈会越来越深，而且不能中断，中断后就不能恢复了。递归如果非常深，就会十分卡顿。）</p><p>React Fiber把<strong>更新过程碎片化</strong>，把一个<strong>耗时长的任务分成很多小片</strong>，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，<strong>这样唯一的线程就不会被独占</strong>，其他任务依然有运行的机会。</p><ul><li>每个<strong>元素</strong>都会有一个fiber对象对应。这些fiber对象之间相互关联，构成了<strong>fiber tree</strong>。</li><li>react fiber的<strong>更新过程是碎片化</strong>的，一次更新会分为n个任务片。每个片执行完成后就会把<strong>控制权交给调度器。</strong></li><li><strong>调度器</strong>会查看浏览器<strong>是否有级别更高的任务</strong>（比如：alert，onclick，等），如果有执行这个高级别任务。</li><li>当整个FiberTree中的节点都被处理后，统一提交所有FiberNode更新。</li><li>好处：细粒度的任务调度能力=&gt;细化了任务的粒度=&gt;降低了任务阻塞的时长，对任务整体来说没有提速。</li></ul><p>遇到<strong>进程阻塞</strong>的问题时，<strong>任务分割、异步调用 和 缓存策略</strong> 是三个显著的解决思路。</p><h2 id="_10-fiber切分小块后为什么由合起来" tabindex="-1"><a class="header-anchor" href="#_10-fiber切分小块后为什么由合起来" aria-hidden="true">#</a> 10. fiber切分小块后为什么由合起来</h2><h2 id="_11-强缓存、协商缓存" tabindex="-1"><a class="header-anchor" href="#_11-强缓存、协商缓存" aria-hidden="true">#</a> 11. 强缓存、协商缓存</h2><h3 id="_11-1-强缓存" tabindex="-1"><a class="header-anchor" href="#_11-1-强缓存" aria-hidden="true">#</a> 11.1 强缓存</h3><p>强缓存：不用请求服务器，在过期时间内直接从缓存中读取资源</p><p><strong>expire和cache-control: max-age=300</strong></p><p>其中max-age=300 public/private/immutable/no-cache/no-store</p><ul><li>public指客户端和代理服务器都可以缓存该资源</li><li>private指只允许客户端缓存该资源</li><li>immutable使用户做了刷新操作，也不向服务器发起http请求</li><li>no-cache指不使用强缓存</li><li>no-store指不使用缓存</li></ul><h3 id="_11-2-协商缓存" tabindex="-1"><a class="header-anchor" href="#_11-2-协商缓存" aria-hidden="true">#</a> 11.2 协商缓存</h3><p>协商缓存：请求服务器是否使用缓存，服务器根据请求头判断</p><p>last-modified（资源最后请求时间）和Etag（请求资源文件的hash值）</p><ul><li>last-modified精确到秒，所以一秒若改变多次，只会更新最后一次</li><li>Etag由服务端生成，增加服务端压力</li></ul><h2 id="_12-强缓存存储方案和策略" tabindex="-1"><a class="header-anchor" href="#_12-强缓存存储方案和策略" aria-hidden="true">#</a> 12. 强缓存存储方案和策略</h2><ul><li><p>对与<strong>频繁变动</strong>的资源：</p><p>使用 <strong>Cache-Control: no-cache</strong>，使浏览器每次都请求服务器，然后配合 <strong>ETag 或者 Last-Modified</strong> 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p></li><li><p>对于<strong>不常变化</strong>的资源：</p><p>通常在处理这类资源时，给它们的 Cache-Control 配置一个<strong>很大的 max-age=31536000 (<strong>一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了</strong>解决更新的问题，<strong>就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而</strong>达到更改引用 URL 的目的</strong>，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。</p></li><li><p>对于<strong>首屏</strong>：</p><p>向vue打包的js，css文件名都是有hash值的，唯一的，页面请求的是新资源，自然不会有缓存问题，但是index.html会存在更新问题，所以一般对index.html使用协商缓存而不是强缓存。</p></li></ul><h2 id="_13-磁盘缓存和内存缓存-何时使用-使用策略" tabindex="-1"><a class="header-anchor" href="#_13-磁盘缓存和内存缓存-何时使用-使用策略" aria-hidden="true">#</a> 13. 磁盘缓存和内存缓存，何时使用，使用策略</h2><ul><li>内存缓存memory cache：<strong>访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存</strong>，关闭 Tab 页面，内存中的缓存也就被释放了。</li><li>磁盘缓存disk cache：根据请求头。<strong>大文件或者内存使用率高时，放在磁盘。</strong></li><li>离线缓存ApplicationCache：运行在浏览器背后的独立线程，一般可以用来实现缓存功能。让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</li><li>推送缓存</li></ul><h2 id="_14-promise、async、generator" tabindex="-1"><a class="header-anchor" href="#_14-promise、async、generator" aria-hidden="true">#</a> 14. promise、async、generator</h2><ul><li><strong>promise</strong>：实现异步编程，为构造函数，传入resolve和reject，通过then方法处理成功或者失败后的回调。通过链式调用，可以防止回调地狱等问题。</li><li><strong>async：</strong> 与await配合，实现异步编程同步化。async返回一个promise对象，await后面为async返回的promise对象，此时await会阻塞后面的代码，等待该promise对象resolve的值。</li><li><strong>generator：</strong> 每调用一次生成器，函数内部状态就改变一次。他是一个带星号的函数，通过yield关键字实现改变。函数.next()就会执行一次，返回value和done</li></ul><h2 id="_15-await异步代码同步化-generator-co库" tabindex="-1"><a class="header-anchor" href="#_15-await异步代码同步化-generator-co库" aria-hidden="true">#</a> 15. await异步代码同步化（generator+co库）</h2><p>async、await 是 co 库的官方实现。也可以看作自带启动器的 generator 函数的语法糖。不同的是，async、await 只支持 Promise 和原始类型的值，不支持 thunk 函数。</p><p>如果用生成器实现await的话，每次next后，会返回一个value，该value为promise，需要value.then的res作为传参放入到迭代器的下一个next中，直到done为true。</p><p>每次执行 generator 函数时自己写启动器比较麻烦。<strong>co函数库 是一个 generator 函数的自启动执行器</strong>，使用条件是 generator 函数的 yield 命令后面，只能是 thunk 函数或 Promise 对象，co 函数执行完返回一个 Promise 对象。该promise对象的res就是await等待执行后获得的值。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// async await</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">readfile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> content1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">readFileWithPromise</span><span class="token punctuation">(</span><span class="token string">&#39;/etc/passwd&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;utf8&#39;</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>content1<span class="token punctuation">)</span>
    <span class="token keyword">const</span> content2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">readFileWithPromise</span><span class="token punctuation">(</span><span class="token string">&#39;/etc/profile&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;utf8&#39;</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>content2<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">&#39;done&#39;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">readfile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token parameter">res</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token parameter">err</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token comment">// generator with co</span>
<span class="token function">co</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>  
    <span class="token keyword">const</span> content1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">readFileWithPromise</span><span class="token punctuation">(</span><span class="token string">&#39;/etc/passwd&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;utf8&#39;</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>content1<span class="token punctuation">)</span>
    <span class="token keyword">const</span> content2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">readFileWithPromise</span><span class="token punctuation">(</span><span class="token string">&#39;/etc/profile&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;utf8&#39;</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>content2<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">&#39;done&#39;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">&#39;fail&#39;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_16-yield和await的区别" tabindex="-1"><a class="header-anchor" href="#_16-yield和await的区别" aria-hidden="true">#</a> 16. yield和await的区别</h2><p>yield：一旦遇到yield，生成器就会暂停执行，next()后恢复</p><p>await：等待一个promise对象执行结果。内部原理为自动迭代器co函数+生成器generator</p><h2 id="_17-生成器generator原理" tabindex="-1"><a class="header-anchor" href="#_17-生成器generator原理" aria-hidden="true">#</a> 17. 生成器generator原理</h2><p>生成器究竟是如何让函数暂停, 又会如何恢复的呢</p><p><strong>协程的执行机制</strong></p><p>协程理解为线程中的一个个任务。<strong>一个线程一次只能执行一个协程</strong>。比如当前执行 A 协程，另外还有一个 B 协程，如果想要执行 B 的任务，就必须在 A 协程中将<strong>JS 线程的控制权转交给 B协程</strong>，那么现在 B 执行，A 就相当于处于暂停的状态。</p><h2 id="_17-怎么了解前端新技术" tabindex="-1"><a class="header-anchor" href="#_17-怎么了解前端新技术" aria-hidden="true">#</a> 17. 怎么了解前端新技术</h2><h2 id="_18-学习前端的规划" tabindex="-1"><a class="header-anchor" href="#_18-学习前端的规划" aria-hidden="true">#</a> 18. 学习前端的规划</h2><h2 id="_19-有没有脱离框架-了解一些框架的原理" tabindex="-1"><a class="header-anchor" href="#_19-有没有脱离框架-了解一些框架的原理" aria-hidden="true">#</a> 19. 有没有脱离框架，了解一些框架的原理</h2><ol><li><p>umi的全局共享数据</p><p>底层基于React.context实现，umi会将model文件夹自定义的hook函数里的state设置为全局状态，当组件要使用时，会在组件外部包裹一层context的provider标签，将state提供给组件使用。同时会提供一个setState的函数，对全局数据进行更改。</p><p>原始的context数据流很乱，umi对其进行二次封装，提用户管理数据流，使之更清晰</p><p>同样的，redux也是将数据流更加清晰。将数据统一放在state树中，通过dispatch一个action，使之执行对应的reducer更改数据。</p></li><li><p>umi自适应</p><p>根节点字体设为屏幕宽度1/10，postcss插件将css的px转为rem，根据媒体查询改变布局</p></li><li><p>echart的大数据渲染优化方案</p><p>appendData：分片加载和增量渲染；sampling：数据过滤；dataZoom分区渲染</p></li></ol><h2 id="_20-反问" tabindex="-1"><a class="header-anchor" href="#_20-反问" aria-hidden="true">#</a> 20. 反问</h2><p>技术栈：面向阿里巴巴内部办事，react、数据可视化、ai结合大模型、webpack</p>`,56),o=[i];function p(r,l){return a(),s("div",null,o)}const u=n(t,[["render",p],["__file","Ali1.html.vue"]]);export{u as default};
