import{_ as o}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as i,o as c,c as p,a,b as e,d as t,f as n}from"./app-0mkQjek1.js";const l="/assets/1721305806966-c1sgSNEg.png",d={},r=n('<h1 id="前端面试题汇总" tabindex="-1"><a class="header-anchor" href="#前端面试题汇总" aria-hidden="true">#</a> 前端面试题汇总</h1><h2 id="_1-html" tabindex="-1"><a class="header-anchor" href="#_1-html" aria-hidden="true">#</a> 1 HTML</h2><ol><li>标签类型与作用：!DOCTYPE（标准声明）、head、body</li><li>H5新特性：语义化标签、webStorage存储、多媒体标签、canvas、websocket、表单增强、地理API、拖拽释放API</li><li>HTML语义化标签：可读性高、有利于SEO、便于开发</li><li>网页组成：结构层、表现层、行为层，对应标准为HTML、CSS、ECMAScript</li><li>HTML4、HTML5、XHTML版本区别：4标签允许不结束，X标签必须结束（要求最高）</li><li>src、href引用外部资源区别：src将资源嵌入文档，href建立链接</li><li><code>&lt;script&gt;</code>标签的 <code>defer</code>与 <code>async</code>属性的区别：都是异步加载脚本， <code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。如果有多个 <code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个 <code>async</code>脚本是不能保证加载顺序的。</li></ol><h2 id="_2-css" tabindex="-1"><a class="header-anchor" href="#_2-css" aria-hidden="true">#</a> 2 CSS</h2><h5 id="预处理器" tabindex="-1"><a class="header-anchor" href="#预处理器" aria-hidden="true">#</a> 预处理器</h5><p>less、sass（scss）、stylus中至少记住某一种的具体使用（优点/不同：语法上-嵌套、引入；作用域-变量操作；混入-抽象，可复用性高）</p><p>less：支持变量 <code>@变量名: 值</code>；支持嵌套；支持简单运算</p><h5 id="display属性" tabindex="-1"><a class="header-anchor" href="#display属性" aria-hidden="true">#</a> display属性</h5><p>none, block(<code>&lt;div&gt;</code>、 <code>&lt;h1&gt;</code>、<code>&lt;p&gt;</code>), inline(<code>&lt;a&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;span&gt;</code>), inline-block(同行排列，但同时拥有 block 元素可以设定宽高的特性), flex, grid, table...</p><h5 id="position属性" tabindex="-1"><a class="header-anchor" href="#position属性" aria-hidden="true">#</a> position属性</h5><p>static, relative（通过 <code>top</code>、 <code>bottom</code>、 <code>left</code> 、 <code>right</code>进行偏移）, absolute(相对于position不为static的父级), fixed（浏览器视窗固定位置）, sticky（相对定位和固定定位切换）</p><p>absolute与fixed差别：absolute会随滚动条移动，fixed不会</p><h5 id="自适应布局" tabindex="-1"><a class="header-anchor" href="#自适应布局" aria-hidden="true">#</a> 自适应布局</h5><p>1）媒体查询@media分别设置；2）使用相对单位(百分比、rem)；3）弹性布局；4）流式布局 eg：圣杯、双飞翼</p><h5 id="标准盒模型与怪异盒模型区别" tabindex="-1"><a class="header-anchor" href="#标准盒模型与怪异盒模型区别" aria-hidden="true">#</a> 标准盒模型与怪异盒模型区别</h5><p>标准的宽高不包含padding和border，怪异的包含（box-sizing: content-box/border-box）</p><h5 id="css可继承属性" tabindex="-1"><a class="header-anchor" href="#css可继承属性" aria-hidden="true">#</a> css可继承属性</h5><p>字体、文本、元素、列表布局、光标</p><h5 id="bfc块级格式化上下文" tabindex="-1"><a class="header-anchor" href="#bfc块级格式化上下文" aria-hidden="true">#</a> BFC块级格式化上下文</h5><p>解决边距重叠问题。原理？如何创建？（display、position、float、overflow）使用场景？（margin重叠、内部浮动、自适应多列布局）</p><h5 id="盒子塌陷" tabindex="-1"><a class="header-anchor" href="#盒子塌陷" aria-hidden="true">#</a> 盒子塌陷</h5><p>出现原因：父元素高度不足，子元素浮动。解决方案？（父元素clear：both；父元素overflow；父元素添加伪元素）</p><h5 id="样式类型" tabindex="-1"><a class="header-anchor" href="#样式类型" aria-hidden="true">#</a> 样式类型</h5><p>行内（内联）&gt; 内部（style标签）&gt; 外部引入</p><p>权重：1000-行内（style=&quot;&quot;）；0100-ID选择器(#) ；0010-类(.)、伪类( : )、属性选择器；0001-标签(div)、伪元素选择器( :: )；0000-通配符(*)、相邻选择器(+)、子选择器(&gt;)、后代选择器(空格)</p><p>浏览器解析css选择器流程：从右向左</p><h5 id="伪类和伪元素" tabindex="-1"><a class="header-anchor" href="#伪类和伪元素" aria-hidden="true">#</a> 伪类和伪元素</h5><p>伪类(:)是在已有元素上不同状态添加样式（:hover, :link, :visited, :disabled, :enabled, :first-child），伪元素(::)是创建不在DOM树中的元素并添加样式（::before, :: after, ::placeholder提示文字, ::first-letter首字母）</p><h5 id="单位" tabindex="-1"><a class="header-anchor" href="#单位" aria-hidden="true">#</a> 单位</h5><p>px-绝对单位，em/rem-相对父节点字体大小（用在width等中时若设定了当前元素字体大小则为相对当前元素字体大小）/HTML根元素字体大小，vw/vh-窗口宽/高</p><h5 id="页面中隐藏与显示" tabindex="-1"><a class="header-anchor" href="#页面中隐藏与显示" aria-hidden="true">#</a> 页面中隐藏与显示</h5><p>display:none(删除)；visibility:hidden(隐藏)；opacity:0(透明度0)；height&amp;weight=0；position:absolute + top&amp;left=-9999px(移出)</p><h5 id="浏览器默认设置、解除" tabindex="-1"><a class="header-anchor" href="#浏览器默认设置、解除" aria-hidden="true">#</a> 浏览器默认设置、解除</h5><h5 id="水平垂直居中实现" tabindex="-1"><a class="header-anchor" href="#水平垂直居中实现" aria-hidden="true">#</a> 水平垂直居中实现</h5><p>1）父position:relative+子position:absolute+top/left/right/bottom:0+margin:auto；</p><p>2）父...+子position:absolute+left/top:50%+margin-left/top:负宽高的一半；</p><p>3）父...+子position:absolute+left/top:50%+transform:translate(-50%,-50%)：</p><p>4）父元素display:flex+justify-content:center+align-items:center；</p><p>5）文字居中：父text-align:center+子line-height:父元素行高；</p><p>6）父元素display:grid,子元素align-self:center+justify-self:center或父元素align-items:center+justify-items:center或place-content:center</p><p>7）在浏览器视窗居中：position:fixed+inset:0px(上下左右都为0)+margin:auto</p><h5 id="三栏布局" tabindex="-1"><a class="header-anchor" href="#三栏布局" aria-hidden="true">#</a> 三栏布局</h5><p>1）弹性布局：父display:flex+左右固定宽度+中flex:1；</p><p>2）grid布局：父display:grid+grid-template-columns:200px 1fx 200px+左右width:200px+中width:100%；</p><p>3）圣杯布局：父padding:0 200px+子float:left+中width:100%+左width:200px+position:relative+margin-left:-100%+left:-200px+右width:200px+position:relative+margin-right:-200px；（缺点：宽度过小时左右会掉行）</p><p>4）双飞翼布局：中间元素加子元素div+子float:left+中width:100%+div-padding:0 200px+左width:200px+margin-left:-100%+右width:200px+margin-right:-200px</p><h5 id="实现loading动画" tabindex="-1"><a class="header-anchor" href="#实现loading动画" aria-hidden="true">#</a> 实现loading动画</h5><p>1）svg；</p><p>2）旋转：animation:spin 2s linear infinite+@keyframes spin {0%{ transform: rotate(0deg)}100%{ transform:rotate(360deg)}}；</p><p>3）点阵：父display:flex+justify-content:space-around+align-items:center+子animation:load 2s ease-in-out infinite+@keyframes load{0%,100%{ transform:scale(0)}50%{ transform:scale(1)}}+时延 子animation-delay:-0.45/0.3/0.15s</p><h5 id="图片格式选择jpg、png、webp、svg" tabindex="-1"><a class="header-anchor" href="#图片格式选择jpg、png、webp、svg" aria-hidden="true">#</a> 图片格式选择JPG、PNG、Webp、SVG</h5><p>JPG、PNG、WebP 是属于点阵图，SVG为矢量图</p><ul><li>点阵图：JPG有损压缩，PNG无损压缩，WebP有损/无损（文件最小）</li><li>点阵动画：WebM：GIF的替代方案，文件更小</li><li>向量图：适用于固定的图形且图片中的颜色变化不多的，eg：logo、icon</li></ul><h5 id="特殊形状实现" tabindex="-1"><a class="header-anchor" href="#特殊形状实现" aria-hidden="true">#</a> 特殊形状实现</h5><p>等腰三角形、扇形、圆形(border-radius)、旋转45度(-webkit-transform: rotate(45deg))、画0.5px的线(transform: scaleY(0.5)+transform-origin: left top)</p><h5 id="切换主题" tabindex="-1"><a class="header-anchor" href="#切换主题" aria-hidden="true">#</a> 切换主题</h5><p>引入新文件覆盖、用不同的类进行切换、写配置文件配置主题、主题调色板保存颜色变量</p><h2 id="_3-js" tabindex="-1"><a class="header-anchor" href="#_3-js" aria-hidden="true">#</a> 3 JS</h2>',58),u=a("li",null,"闭包：可以访问外部函数的变量",-1),h=a("li",null,"事件委托：利用事件冒泡机制来管理事件处理程序 。将事件处理程序添加到一个父元素，而不是每个子元素，以提高性能和简化代码",-1),k=a("li",null,"异步编程：promise（ES6），async/await（ES8引入的语法糖，用于简化promise，将异步变为同步写法）",-1),f=a("li",null,"原型链、继承",-1),m={href:"https://juejin.cn/post/7086325194934976519",target:"_blank",rel:"noopener noreferrer"},b=n(`<h2 id="_4-框架" tabindex="-1"><a class="header-anchor" href="#_4-框架" aria-hidden="true">#</a> 4 框架</h2><ol><li>你理解的框架？React - 组件化提高了代码的复用性和可维护性，适合大型复杂项目；Vue - 渐进式易上手，双向数据绑定，适合快速开发和迭代项目</li></ol><h3 id="react" tabindex="-1"><a class="header-anchor" href="#react" aria-hidden="true">#</a> React</h3><h5 id="纯函数" tabindex="-1"><a class="header-anchor" href="#纯函数" aria-hidden="true">#</a> 纯函数</h5><ol><li>输入相同内容时得到的输出也相同</li><li>不改变函数以外的存在（没有副作用）</li></ol><h5 id="jsx" tabindex="-1"><a class="header-anchor" href="#jsx" aria-hidden="true">#</a> JSX</h5><p>将UI与js逻辑相融</p><p>本质：生成 React 元素(elements)，是 <code>React.createElement(component, props, ...children)</code> 函式的语法糖</p><p>规则：1. return单一根元素；2. 所有标签都要闭合；3. 所有属性名都用小驼峰形式（<code>class </code>→ <code>className</code>、<code>stroke-width</code> → <code>strokeWidth</code>）</p><h5 id="虚拟dom" tabindex="-1"><a class="header-anchor" href="#虚拟dom" aria-hidden="true">#</a> 虚拟DOM</h5><p>使用：先更新虚拟dom，通过diff算法比较新旧虚拟dom后，再将更新部分应用到真实dom中</p><p>优点：可以使用声明式语法编写React，避免频繁直接操作DOM</p><p>缺点：多一层操作，跟原生操作 DOM 相比，通常会比较慢</p><h5 id="hooks" tabindex="-1"><a class="header-anchor" href="#hooks" aria-hidden="true">#</a> hooks</h5><p>用 <code>use</code> 开头的函数，只能在React函数的最顶层或自定义hook中使用</p><ul><li><strong>useState</strong> ：用于定义和保存元件中状态(state)，接收一个初始值，返回一个包含两个值的数组，第一个值是现在 state 的值，第二个值是一个 setter function，可以通过这个 setter function 更新 state 值并触发 re-render。</li><li><strong>useEffect</strong> ：当想执行副作用时，会通过 useEffect 处理，例如：fetch api、记录追踪、setInterval()。需要传送两个参数在 <code>useEffect</code> 中，第一是一个 setup function，代表我们想执行的副作用代码，如果最后要清除这个副作用，需要return一个 cleanup function; 第二个参数是一个依赖数组，可选，可传入props或state，不填时每次组件渲染后执行一次，填[]时初始渲染后执行一次，有依赖时初始渲染和指定的变量发生变化时执行。</li><li><strong>useContext</strong> ：接收上级传递的Context数据</li><li><strong>useReducer</strong> ：也是一种管理 state 的 hook，可作为 <code>useState</code> 替代方案，适用于复杂状态管理（<code>useState</code> 是使用 <code>useReducer</code> 构建的）。接收两个参数，第一个是 reducer函数，第二个为初始值。会返回两个值，现在 state 的值和 <code>dispatch</code> 方法（传递值给reducer函数执行）。</li><li><strong>useCallback</strong> ：缓存函数。会返回一个被 memoized 的 callback 函数，使用useCallback钩子包裹的回调函数是memoized函数，初次调用该函数时，缓存参数和计算结果，再次调用这个函数时，如果第二个参数依赖项没有发生改变，则直接返回缓存结果，不会重新渲染。</li><li><strong>useMemo</strong> ：缓存计算结果。传入一个创建函数和依赖项目，创建函数会需要返回一个值，只有在依赖发生变化时，才会更新值。</li><li><strong>useRef</strong> ：获取DOM节点 或 保存变量，通常用于保存不需要渲染的变量，如计时器id。会返回一个可变的 ref 对象，内含 <code>.current</code> 属性，会被初始化为传入的参数值(initialValue)。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&#39;&#39;</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> initialState<span class="token punctuation">)</span>

<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;useEffect - update title&#39;</span><span class="token punctuation">)</span>
  document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">You clicked </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times</span><span class="token template-punctuation string">\`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">//app.tsx创建Context</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> UserContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token string">&#39;&#39;</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">App</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;App&quot;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>UserContext<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">&#39;chuanshi&#39;</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>ComponentC <span class="token operator">/</span><span class="token operator">&gt;</span> <span class="token comment">//数据传给ComponentC</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>UserContext<span class="token punctuation">.</span>Provider<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">//ComponentE组件消费数据</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>UserContext<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;../App&#39;</span>

<span class="token keyword">function</span> <span class="token function">ComponentE</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>UserContext<span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>user<span class="token punctuation">}</span> <span class="token operator">-</span> <span class="token punctuation">{</span>channel<span class="token punctuation">}</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token keyword">const</span> onClick <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">name</span><span class="token operator">:</span> string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> userInfo <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;小明&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//获取DOM eg：进入页面时input获取焦点</span>
<span class="token keyword">const</span> inputRef <span class="token operator">=</span> useRef<span class="token operator">&lt;</span>HTMLInputElement<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    inputRef<span class="token punctuation">.</span>current <span class="token operator">&amp;&amp;</span> inputRef<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">//存储变量</span>
<span class="token keyword">const</span> intervalRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token punctuation">{</span> <span class="token literal-property property">current</span><span class="token operator">:</span> number <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,17),g={href:"https://juejin.cn/post/6844904157892050957",target:"_blank",rel:"noopener noreferrer"},v=n('<h5 id="渲染列表时需要加上key属性" tabindex="-1"><a class="header-anchor" href="#渲染列表时需要加上key属性" aria-hidden="true">#</a> 渲染列表时需要加上key属性</h5><p>key 可以让 React 知道，哪些子元件被新增、 移除，或是修改。这一来可以避免一些跟状态改变有关的 bug，二来也可以让 React 在更新时的渲染更有效率</p><h3 id="vue" tabindex="-1"><a class="header-anchor" href="#vue" aria-hidden="true">#</a> Vue</h3><ol><li>组件间通信：父子-props接收数据，<code>$emit</code>触发事件；兄弟-通过共同父组件传递，或状态管理工具Vuex；全局-EventBus-<code>$emit</code>传递数据，<code>$on</code>接收数据</li></ol><h2 id="_5-浏览器" tabindex="-1"><a class="header-anchor" href="#_5-浏览器" aria-hidden="true">#</a> 5 浏览器</h2><h5 id="浏览器输入网址后流程" tabindex="-1"><a class="header-anchor" href="#浏览器输入网址后流程" aria-hidden="true">#</a> 浏览器输入网址后流程</h5><p>查找本地是否有缓存 → DNS解析域名获得对应ip → 建立TCP连接 → 对该ip发送http请求 → 收到服务器端响应 → 关闭TCP连接 → 浏览器渲染 → JS引擎执行JS代码</p><h5 id="浏览器渲染流程" tabindex="-1"><a class="header-anchor" href="#浏览器渲染流程" aria-hidden="true">#</a> 浏览器渲染流程</h5><p>DOM树 + CSSOM树 → 渲染树 → 布局（布局树） → 绘制 → 合成</p><h5 id="回流重绘" tabindex="-1"><a class="header-anchor" href="#回流重绘" aria-hidden="true">#</a> 回流重绘</h5><ul><li>回流（布局阶段）：改变布局时，eg：改变 <code>width</code>、<code>height</code>、<code>font-size</code> 等</li><li>重绘（绘制阶段）：改变颜色或其他不影响布局的属性时，eg：改变 <code>outline</code>、<code>visibility</code>、<code>color</code>、<code>background-color</code>等</li></ul><p>减少回流重绘：避免频繁操作DOM</p><h5 id="spa" tabindex="-1"><a class="header-anchor" href="#spa" aria-hidden="true">#</a> SPA</h5><p>优点：用户体验好、前后端分离</p><p>缺点：SEO较差、JS文件过大</p><p>解决方法：</p><ol><li>SSR (Server-side Rendering) 或 SSR (Server-side Rendering) + CSR (Client-side Rendering)</li><li>懒加载(lazy loading) 、 代码分割(code splitting) 、压缩等</li></ol><h5 id="事件委托、捕获、冒泡" tabindex="-1"><a class="header-anchor" href="#事件委托、捕获、冒泡" aria-hidden="true">#</a> 事件委托、捕获、冒泡</h5><p><strong>事件冒泡</strong>：当一个元素接收到事件的时候，会把他接收到的事件传给自己的父级，一直到 <code>window</code> （注意这里传递的仅仅是事件，例如 <code>click、focus</code>等等这些事件， 并不传递所绑定的事件函数。）</p><p>eg：给三个盒子依次绑定点击事件，当点击盒子的时候，会依次触发父级元素的点击事件</p><p><strong>事件捕获</strong>：当鼠标点击或者触发 <code>dom</code>事件时（被触发 <code>dom</code>事件的这个元素被叫作事件源），浏览器会从根节点 =&gt;事件源（由外到内）进行事件传播</p><p>先事件捕获再事件冒泡</p><p><strong>事件委托</strong>：也称为 <code>事件代理</code>。就是利用 <code>事件冒泡</code>，把子元素的事件都绑定到父元素上。如果子元素阻止了事件冒泡，那么委托就无法实现。</p><h5 id="dom生命周期" tabindex="-1"><a class="header-anchor" href="#dom生命周期" aria-hidden="true">#</a> DOM生命周期</h5><p>HTML 文件完全载入、解析 → <code>DOMContentLoaded</code> → CSS 样式表、图片等各类资源载入 → <code>load</code></p><p>使用者离开网页前 → <code>beforeunload</code> → 离开或关闭网页 → <code>unload</code></p><h5 id="存储" tabindex="-1"><a class="header-anchor" href="#存储" aria-hidden="true">#</a> 存储</h5><p>cookie：服务器生成sessionid，存储在浏览器，每次请求时都会被夹带在 HTTP header 中。通过 <code>Expires</code> 标明失效时间、或 <code>Max-Age</code> 标明有效时间长度，没有设置的话，预设是关闭浏览器之后失效。4KB 左右。</p><p>localStorage：键值对形式存储字符串，除非在用户端被手动删除，否则将永久保存。5MB~10MB 左右。用于存储内容稳定的资源，如logo、base64的照片。</p><p>sessionStorage：键值对形式存储字符串，在每次关闭该页面后就会自动被清除。5MB~10MB 左右。用于表单信息维护、本地浏览记录。</p><p>IndexedDB：浏览器端非关系型数据库，可存储所有格式，异步存取，可存取大型数据</p><p>增加cookie安全性：1. <code>Secure</code> ：只有通过HTTPS协议时才会传送给服务器；2. <code>HttpOnly</code> ：避免 JavaScript 的 <code>Document.cookie</code>方法取得 <code>HttpOnly cookies</code>，可以避免跨站脚本攻击XSS</p><h5 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存" aria-hidden="true">#</a> 缓存</h5><p><strong>强缓存：</strong></p><p>浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status Code: 200 OK</p><p>条件：在过期时间内则为强制缓存</p><ul><li>Expires：过期时间（http1.0）</li><li>Cache-Control：max-age=xxx 缓存有效时间（http1.1，会覆盖Expires）</li></ul><p><strong>协商缓存:</strong></p><p>向服务器发送请求，服务器通过请求头中的If-Modified-Since（Last-Modified）或者 If-None-Match（Etag）字段检查资源是否更新，更新则返回新资源和200，没有更新则返回304，告诉浏览器直接从缓存获取资源</p><p>条件：缓存已过期 或者 Cache-Control：no-cache</p><ul><li>ETag/If-None-Match ：<code>ETag</code>是一个资源版本的唯一标识符，后续请求该资源时，会在请求头中携带 <code>If-None-Match</code>字段，其值为先前接收到的 <code>ETag</code>，服务器会根据这个值来判断资源是否有更新。（http1.1，优先级更高）</li><li>Last-Modified/If-Modified-Since：类似于 <code>ETag</code>机制，但 <code>Last-Modified</code>记录的是资源最后修改的时间。浏览器在后续请求时，会在请求头中携带 <code>If-Modified-Since</code>字段，其值为先前接收到的 <code>Last-Modified</code>时间。服务器会检查资源的最后修改时间是否在这个时间之后。（http1.0）</li></ul><p><code>cache-control: no-store</code> // 不缓存，直接每次都请求最新资源</p><h3 id="操作系统" tabindex="-1"><a class="header-anchor" href="#操作系统" aria-hidden="true">#</a> 操作系统</h3><ol><li>32位系统和64位系统的区别：32位系统每次最多处理32位（二进制位）的数据，最多支持4GB的物理内存。64位系统每次最多处理64位的数据，最高支持到约18.4亿GB的内存寻址。</li><li>进程和线程：进程是操作系统中运行的程序的独立实例，每个进程都有独立的地址空间、数据段、代码段和堆栈。线程是进程中的执行单元，一个进程可以包含多个线程，所有线程共享进程的内存空间。</li><li>进程间通信：消息队列、管道、共享内存、信号、套接字</li><li>线程间通信：全局变量/共享内存、锁（互斥锁、读写锁、自旋锁）、条件变量、事件机制</li></ol><h2 id="_6-计算机网络" tabindex="-1"><a class="header-anchor" href="#_6-计算机网络" aria-hidden="true">#</a> 6 计算机网络</h2><h3 id="http" tabindex="-1"><a class="header-anchor" href="#http" aria-hidden="true">#</a> HTTP</h3><h5 id="http-1" tabindex="-1"><a class="header-anchor" href="#http-1" aria-hidden="true">#</a> HTTP/1</h5><ol><li>使用标头中的 <code>If-Modified-Since</code>、<code>Expires</code> 来做为缓存的判断标准，这两者都是以时间作为依据</li></ol><h5 id="http-1-1" tabindex="-1"><a class="header-anchor" href="#http-1-1" aria-hidden="true">#</a> HTTP/1.1</h5><ol><li>实现持久连接；</li><li>添加状态码 <code>100 (Continue)</code> 机制：先发送请求头到服务器，若无问题则响应100，再发送带正文的请求，以减少浪费；</li><li>快取缓存：引入更多的缓存策略，例如：<code>Etag</code>、<code>If-Unmodified-Since</code>、<code>If-Match</code>、<code>If-None-Match</code>；</li><li>增加了 Host 字段，用来指定服务器的域名，可以将请求发往同一台服务器上的不同网站；</li><li>新增了许多请求方法，如 <code>CONNECT</code>、<code>TRACE</code> 、<code>OPTIONS</code> 等。</li></ol><h5 id="http-2" tabindex="-1"><a class="header-anchor" href="#http-2" aria-hidden="true">#</a> HTTP/2</h5><ol><li>多路复用：让同一个 TCP 连接中，同时发送和接受多个请求，并且不用等到前一个请求收到回应，透过这个机制，解决了过往在 HTTP 层级的的头部阻塞问题</li><li>优先请求顺序：每个数据包在发送的时候会带上一个唯一的数据流编号 ID (<code>stream ID</code>)，客户端可以指定数据流的优先级</li><li>请求头压缩：HPACK 算法使用一份索引表来定义常用的 http header，并把 http header 存放在表里，请求的时候只需要发送在表里的索引位置即可，不须用传完整的标头</li><li>服务器主动推送数据，减少客户端的请求次数</li></ol><h3 id="跨域" tabindex="-1"><a class="header-anchor" href="#跨域" aria-hidden="true">#</a> 跨域</h3><p>产生原因：同源策略限制网页只能存取同源的资源，同源指协议、域名、端口都相同</p><h5 id="cors" tabindex="-1"><a class="header-anchor" href="#cors" aria-hidden="true">#</a> CORS</h5><p>后端工程师在服务器端做 CORS 请求头的设定</p><p>分为简单请求（get、post、head）和非简单请求（除简单请求以外的其他请求先发送预检请求OPTIONS，满足条件后再发送CORS请求）</p><ol><li><code>Access-control-allow-origin</code>：设置允许跨域请求的源，要么是请求时 <code>Origin</code>字段的值，要么是*</li><li><code>Access-control-allow-credentials：true</code> // 允许跨域发送cookie，此时origin不能设置为*</li><li><code>Access-Control-Allow-Methods: GET, POST, PUT </code> // 服务器支持的所有跨域请求的方法，对应 <code>Access-Control-Request-Method</code></li><li><code>Access-Control-Allow-Headers: X-Custom-Header</code> // 服务器所支持的所有头信息字段，对应 <code>Access-Control-Request-Headers</code></li><li><code>Access-Control-Max-Age</code> // 指定本次预检请求的有效期，单位为秒。</li></ol><h5 id="jsonp" tabindex="-1"><a class="header-anchor" href="#jsonp" aria-hidden="true">#</a> JSONP</h5><p>通过 <code>&lt;script&gt;</code> 的src 填上目标地址从而发出 GET 请求</p><h5 id="proxy正向代理" tabindex="-1"><a class="header-anchor" href="#proxy正向代理" aria-hidden="true">#</a> PROXY正向代理</h5><p>vpn</p><h5 id="nginx反向代理" tabindex="-1"><a class="header-anchor" href="#nginx反向代理" aria-hidden="true">#</a> nginx反向代理</h5><p>iframe</p><p>websocket</p><h2 id="_7-数据结构和算法" tabindex="-1"><a class="header-anchor" href="#_7-数据结构和算法" aria-hidden="true">#</a> 7 数据结构和算法</h2><p>排序</p><p>二叉树</p><p>哈希表</p><p>深度优先遍历、广度优先遍历</p><p>防抖</p><p>节流</p><p>promise</p><h2 id="_8-开发工具" tabindex="-1"><a class="header-anchor" href="#_8-开发工具" aria-hidden="true">#</a> 8 开发工具</h2><h3 id="工具版本汇总" tabindex="-1"><a class="header-anchor" href="#工具版本汇总" aria-hidden="true">#</a> 工具版本汇总</h3><ol><li>HTML：2.0-3.2-4.0-4.01-XHTML1.0-5.0</li><li>CSS：3</li><li>JS：ECMAScript2015（ES6）- ECMAScript 2024 (ES14)</li><li>TS：5.3</li><li>React：18.2，umi：4</li><li>Vue：3.3.4</li><li>Node.js：18+</li><li>webpack：6</li><li>http：1.0-1.1-2-3</li></ol><h3 id="git" tabindex="-1"><a class="header-anchor" href="#git" aria-hidden="true">#</a> git</h3><p><strong>git命令：</strong></p><p>add\\commit\\push</p><p>pull\\clone\\checkout</p><p><img src="'+l+'" alt="1721305806966" loading="lazy"></p><p>branch-创建or列出or删除(-d)分支\\checkout-切换分支or放弃修改\\merge-合并分支\\rebase-改变基底</p><p>reset-回退版本(后面提交的版本会删除)\\revert-反做(修改之前版本不影响已提交版本)</p><h3 id="前端模块化规范" tabindex="-1"><a class="header-anchor" href="#前端模块化规范" aria-hidden="true">#</a> 前端模块化规范</h3><h5 id="commonjs" tabindex="-1"><a class="header-anchor" href="#commonjs" aria-hidden="true">#</a> CommonJS</h5><ul><li>Node.js环境</li><li><code>require</code>、<code>module.export</code></li><li>同步载入</li><li>一个文件为一个模块</li></ul><h5 id="amd" tabindex="-1"><a class="header-anchor" href="#amd" aria-hidden="true">#</a> AMD</h5><ul><li>Async Module Definition - 非同步模组定义</li><li>浏览器环境</li><li>可在一个文件中定义多个模块</li></ul><h5 id="cmd" tabindex="-1"><a class="header-anchor" href="#cmd" aria-hidden="true">#</a> CMD</h5><p>Common Module Definition，结合 <code>CommonJS</code> 和 <code>AMD</code> 规范的优点</p><ul><li>浏览器环境</li><li>异步模块加载</li><li>一个文件为一个模组</li></ul><h5 id="umd" tabindex="-1"><a class="header-anchor" href="#umd" aria-hidden="true">#</a> UMD</h5><p>Universal Module Definition，解决使用不同标准产生的问题，可以让 <code>AMD</code> 和 <code>CommonJS</code> 使用同一份文件</p><h5 id="es-module-esm" tabindex="-1"><a class="header-anchor" href="#es-module-esm" aria-hidden="true">#</a> <strong>ES Module(ESM)</strong></h5><p>ES6实现了模块的功能，并结合了 <code>CommonJS</code> 和 <code>AMD</code> 的两者优点</p><ul><li>类似 <code>CommonJS</code>，引入简单的语法如 <code>export</code> 和 <code>import</code>，并且也是一个文件为一个模块</li><li>类似于 <code>AMD</code> ，为异步加载</li><li>多用于浏览器环境，nodejs环境也支持</li></ul><h3 id="打包" tabindex="-1"><a class="header-anchor" href="#打包" aria-hidden="true">#</a> 打包</h3><h4 id="webpack" tabindex="-1"><a class="header-anchor" href="#webpack" aria-hidden="true">#</a> webpack</h4><ol><li>打包流程：1）解析配置文件webpack.config.js；2）Entry-读取入口文件及依赖模块，构建依赖图；3）Module-递归解析模块依赖；4）Loader-使用相应Loader加载模块源代码；5）Plugin-通过插件对加载的模块进行打包优化等处理；6）Output-打包后文件输出到指定目录</li><li>module，chunk 和 bundle 区别：同一份逻辑代码在不同转换场景下的三个名字：直接写出来的是 module，webpack 处理时是 chunk，最后生成浏览器可以直接运行的 bundle</li><li>优化打包速度：1）使用生产模式；2）代码拆分成多个bundle；3）用Tree Shaking移除未使用的代码；4）缓存</li><li>loader和plugin区别：loader本质为函数，对接受的非js内容进行转换（使用 style-loader 和 css-loader 来处理），plugin是插件，扩展webpack功能，通过webpack提供的生命周期钩子改变输出结果</li><li>自写loader</li></ol><p><strong>Loaders</strong> : 用于转换模块的源代码，常见的有：</p><ul><li><code>babel-loader</code>: 转换ES6+代码为兼容旧浏览器的JavaScript代码。</li><li><code>css-loader</code>: 允许你 <code>import</code>或 <code>require</code>CSS文件。</li><li><code>style-loader</code>: 将CSS注入到DOM中。</li><li><code>file-loader</code>: 处理图片、字体等文件，并返回URL。</li></ul><p><strong>Plugins</strong> : 用于执行更复杂的任务，常见的有：</p><ul><li><code>HtmlWebpackPlugin</code>: 自动生成HTML文件并注入打包后的资源。</li><li><code>CleanWebpackPlugin</code>: 在每次构建前清理输出目录。</li><li><code>MiniCssExtractPlugin</code>: 将CSS提取到单独的文件中。</li></ul><h4 id="vite" tabindex="-1"><a class="header-anchor" href="#vite" aria-hidden="true">#</a> vite</h4><p>优点：本地开发、热模块更新，通过Rollup打包</p><p>基本上除了 Next （React）与 Angular 之外，热门的框架都是选 Vite</p><h4 id="glup" tabindex="-1"><a class="header-anchor" href="#glup" aria-hidden="true">#</a> glup</h4><h2 id="_9-登录问题" tabindex="-1"><a class="header-anchor" href="#_9-登录问题" aria-hidden="true">#</a> 9 登录问题</h2><p>登录页面需注意内容：</p><p>信息加密：对称、非对称</p><p>token鉴权、jwt</p><p>第三方登录</p><h2 id="_10-web安全" tabindex="-1"><a class="header-anchor" href="#_10-web安全" aria-hidden="true">#</a> 10 web安全</h2><h5 id="ddos攻击-分散式阻断服务攻击" tabindex="-1"><a class="header-anchor" href="#ddos攻击-分散式阻断服务攻击" aria-hidden="true">#</a> DDos攻击（分散式阻断服务攻击）</h5><p>攻击方式：多台计算机发送大量的合法请求造成资源过载，导致服务停止</p><p>防御措施：</p><ol><li>增加网站可承受容量（使用可扩展资源临时扩大）；</li><li>反向代理（现在云端厂商多半有机器学习的解决方案，会去对流量做分析，可以辨认哪些访客是真的，哪些是假的）；</li><li>CDN</li></ol><h5 id="xss攻击-跨站脚本攻击" tabindex="-1"><a class="header-anchor" href="#xss攻击-跨站脚本攻击" aria-hidden="true">#</a> XSS攻击（跨站脚本攻击）</h5><p>攻击方式：从客户端注入攻击脚本，最常见的是把 JavaScript 的脚本注入到输入框中，来达到某种目的，例如：窃取 Cookie、Session、密码，篡改网页内容</p><p>防御措施：</p><ol><li>将输入框中的HTML标签转换为字符串格式（如果攻击者输入 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> ，则把 <code>&lt;</code> 转成 <code>&amp;lt</code>）；</li><li>通过 CSP (content security policy) 来设定有哪些域名中的脚本会被浏览器认为是该被执行的，然后浏览器只执行那些该被执行的脚本；</li><li>任何允许用户输入的内容都要检查，删除相关的关键字，如 <code>&lt;script&gt;</code> 、 <code>onerror</code> 等指令</li></ol><h5 id="csrf攻击-跨站请求伪造" tabindex="-1"><a class="header-anchor" href="#csrf攻击-跨站请求伪造" aria-hidden="true">#</a> CSRF攻击（跨站请求伪造）</h5><p>攻击方式：强迫使用者在已经验证身份的网站中，执行某些恶意的伪造操作</p><p>防御措施：</p><ol><li>增加验证</li><li>不用GET请求做关键操作，改为POST请求后必须用户提交请求才会被攻击</li><li>检查HTTP 请求头中的 Referrer 字段，确保请求不是来自于其他网站（也可能被篡改）</li><li>使用CSFR token：让网站用另外的 token 验证使用者的身份，而不是通过 cookie</li><li>SameSite Cookie：限制cookie只能被自己网站使用，即限制其他域来的请求不带上 Cookie</li></ol><h5 id="sql注入攻击" tabindex="-1"><a class="header-anchor" href="#sql注入攻击" aria-hidden="true">#</a> SQL注入攻击</h5><p>攻击方式：通过修改 SQL 语句，达到对数据库的恶意攻击</p><p>防御措施：</p><ol><li>用正则表达式对用户输入进行检查，如果有符合 SQL 语句的关键字，就替换成合法字符</li><li>Query Parameterization（参数化查询）：先将 SQL 语句进行编译，最后再将参数丢入做执行</li><li>Object Relational Mapping (ORM，把数据库映射成对象)：使用 ORM 而非原始的 SQL 语句可以直接避免 SQL Injection</li></ol><h2 id="_11-性能优化" tabindex="-1"><a class="header-anchor" href="#_11-性能优化" aria-hidden="true">#</a> 11 性能优化！</h2><ol><li>web页面性能优化措施：1）代码拆分为多个bundle，减少初始加载事件；2）懒加载；3）压缩文件大小；4）使用CDN（内容分发网络）；5）缓存；6）减少http请求；7）使用HTTP/2</li><li>减少页面首屏时间（FCP）：1）代码拆分；2）懒加载；3）压缩；4）使用CDN；5）服务器端渲染（SSR）；6）预加载（preload）</li><li>性能监测和优化工具：Chrome DevTools</li><li>单元测试和集成测试框架：Jest</li></ol><h2 id="_12-新技术" tabindex="-1"><a class="header-anchor" href="#_12-新技术" aria-hidden="true">#</a> 12 新技术</h2><h5 id="bun" tabindex="-1"><a class="header-anchor" href="#bun" aria-hidden="true">#</a> Bun</h5><p>js运行环境：Nodejs → Deno → Bun</p><p>优点：</p><ul><li>集js执行、测试、打包、包管理一体化</li><li>速度快</li><li>支持TS</li><li>兼容CJS和ESM</li></ul>',136);function x(S,C){const s=i("ExternalLinkIcon");return c(),p("div",null,[r,a("ol",null,[u,h,k,f,a("li",null,[e("ajax、 XMLHttpRequest、fetch、axios区别："),a("a",m,[e("https://juejin.cn/post/7086325194934976519"),t(s)])])]),b,a("p",null,[a("strong",null,[a("a",g,[e("https://juejin.cn/post/6844904157892050957"),t(s)])])]),v])}const _=o(d,[["render",x],["__file","01huizong.html.vue"]]);export{_ as default};
