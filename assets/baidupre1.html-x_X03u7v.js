import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as s,c as a,f as e}from"./app-0SoiKzJB.js";const t="/assets/1721740459058-UAlpprm0.png",p="/assets/1721740480112-Bdp-pv7H.png",o="/assets/1722668888130-F68OtYHe.png",i={},c=e(`<h1 id="百度一面" tabindex="-1"><a class="header-anchor" href="#百度一面" aria-hidden="true">#</a> 百度一面</h1><h2 id="_1-自我介绍" tabindex="-1"><a class="header-anchor" href="#_1-自我介绍" aria-hidden="true">#</a> 1 自我介绍</h2><h2 id="_2-三个项目里做的最好的是哪个-负责哪些模块-做的具体工作" tabindex="-1"><a class="header-anchor" href="#_2-三个项目里做的最好的是哪个-负责哪些模块-做的具体工作" aria-hidden="true">#</a> 2 三个项目里做的最好的是哪个，负责哪些模块，做的具体工作</h2><p>铁道仿真系统 - 实验室真实项目</p><h2 id="_3-了解数组的reduce方法吗" tabindex="-1"><a class="header-anchor" href="#_3-了解数组的reduce方法吗" aria-hidden="true">#</a> 3 了解数组的reduce方法吗</h2><p>对数组中的每个元素按序执行一个提供的 <strong>reducer</strong> 函数，每一次运行 <strong>reducer</strong> 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值</p><h2 id="_4-js原型和原型链" tabindex="-1"><a class="header-anchor" href="#_4-js原型和原型链" aria-hidden="true">#</a> 4 js原型和原型链</h2><p>每个对象（object）都有一个私有属性指向另一个名为 <strong>原型</strong> （prototype）的对象。原型对象也有一个自己的原型，层层向上直到一个对象的原型为 <code>null</code>，形成<strong>原型链</strong></p><ul><li>每一个构造函数都一个prototype属性，指向原型对象，这个对象的所有属性和方法都会被构造函数所拥有。</li><li>每一个对象都会有一个__proto__属性指向构造函数的prototype原型对象，这让对象可以使用构造函数原型对象的属性和方法</li></ul><blockquote><p>即对象的 <code>__proto__</code>属性等于创建它的构造函数的 <code>prototype</code>属性</p><p><code>__proto__</code>属性虽然在ECMAScript 6语言规范中标准化，但是不推荐被使用，现在更推荐使用 <code>Object.getPrototypeOf(obj)</code></p></blockquote><ul><li>原型对象中默认有一个 <code>constructor</code>属性，指回该构造函数</li></ul><h2 id="_5-class来new一个新对象-class和构造函数的区别-编译过程中涉及到this指向、执行作用域、new的过程等的区别-深入讲解" tabindex="-1"><a class="header-anchor" href="#_5-class来new一个新对象-class和构造函数的区别-编译过程中涉及到this指向、执行作用域、new的过程等的区别-深入讲解" aria-hidden="true">#</a> 5 class来new一个新对象，class和构造函数的区别？编译过程中涉及到this指向、执行作用域、new的过程等的区别，深入讲解</h2><p>class是构造函数的语法糖</p><ol><li>语法：ES6 类使用 <code>class</code> 关键字来定义类，传统的构造函数使用函数来定义。</li><li>继承：类使用 <code>extends</code> 关键字来实现继承，构造函数使用原型链来实现继承，需要更多的手动操作。</li><li>定义方法：在类中，方法可以直接在类的内部定义，在构造函数中，方法通常通过添加到构造函数的原型上来定义。</li><li>静态方法： 类允许定义静态方法，这些方法可以在类本身上调用，而不需要创建类的实例，构造函数通常不支持直接定义静态方法，需要通过构造函数本身定义静态方法</li><li>构造函数：类中，构造函数必须命名为 <code>constructor</code>，在构造函数中，构造函数可以有任何名称；类中只能有一个构造函数，构造函数可以拥有多个构造函数，通过不同的参数进行重载。</li></ol><p>其他区别：</p><ol><li>类的内部所有定义的方法，都是不可枚举的（es5中prototype的方法是可以进行枚举的）</li><li>类的构造函数必须通过 new 进行调用，这是它跟普通构造函数的一个主要区别，后者不用new也可以执行</li><li>继承的底层区别：ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//1.语法</span>
<span class="token comment">//class类</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name；
  <span class="token punctuation">}</span>
  <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Hello, my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Hello, my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">//2.继承</span>
<span class="token comment">//类</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> grade</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// super关键字继承属性</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>grade <span class="token operator">=</span> grade<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//构造函数</span>
<span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> grade</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>grade <span class="token operator">=</span> grade<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Student<span class="token punctuation">;</span>


<span class="token comment">//3.定义静态方法</span>
<span class="token comment">//类</span>
<span class="token keyword">class</span> <span class="token class-name">MathUtil</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
MathUtil<span class="token punctuation">.</span><span class="token function">square</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//构造函数</span>
<span class="token keyword">function</span> <span class="token function">MathUtil</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
MathUtil<span class="token punctuation">.</span><span class="token function-variable function">square</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
MathUtil<span class="token punctuation">.</span><span class="token function">square</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_6-双等于和三等于区别-分别比较的什么" tabindex="-1"><a class="header-anchor" href="#_6-双等于和三等于区别-分别比较的什么" aria-hidden="true">#</a> 6 双等于和三等于区别，分别比较的什么</h2><ul><li>双等于：在比较两个值之前，会先强制转换类型与值（两个引用数据类型之间比较的是 <code>地址</code>）</li><li>三等于：严格比较值和类型</li></ul><blockquote><p>还有object.is()方法进行同值比较，<code>Object.is()</code> 和 <code>===</code> 之间的唯一区别在于它们处理带符号的 0 和 <code>NaN</code> 值的时候</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">+</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// true</span>
<span class="token number">NaN</span> <span class="token operator">===</span> <span class="token number">NaN</span><span class="token punctuation">;</span><span class="token comment">// false</span>

Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span>； <span class="token comment">// false</span>
Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">,</span> <span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_7-双等于涉及隐式转换-讲一下隐式转换-有哪些场景涉及" tabindex="-1"><a class="header-anchor" href="#_7-双等于涉及隐式转换-讲一下隐式转换-有哪些场景涉及" aria-hidden="true">#</a> 7 双等于涉及隐式转换，讲一下隐式转换，有哪些场景涉及</h2><p>场景：<code>==</code> 比较、<code>+/-/&gt;/&lt;</code> 运算、if判断、<code>！</code>取反</p><p>转换规则：隐式转换为数字、字符串、布尔形式</p><ol><li>+/-/==时转换流程：</li></ol><ul><li>Object =&gt; String =&gt; Number</li><li>Boolean =&gt; Number</li><li>undefined/null =&gt; Number</li><li><code>NaN</code>较为特殊，js规定它与任何数据比较均为 false，包括其本身</li></ul><blockquote><p>当与引用类型 + 时是看做字符串的拼接，但是-运算符只会视为计算，故与引用类型 - 时，只会返回 <code>NaN</code></p></blockquote><ol start="2"><li><code>&gt;/&lt;</code>时：String 的内容为 Number 时转换为 Number</li><li>if判断：true、1 被视为 true，false、“”、0、null、undefined、NaN 被视为 false</li><li>连续两次取反可以将非布尔值转成布尔值</li></ol><blockquote><p>null、NaN、undefined和string、number、boolean、object类型比较时，都不做隐式转换，比较的结果<strong>直接为false</strong></p></blockquote><h2 id="_8-空数组隐式转换成什么" tabindex="-1"><a class="header-anchor" href="#_8-空数组隐式转换成什么" aria-hidden="true">#</a> 8 空数组隐式转换成什么</h2><p>空数组[]：</p><ul><li>比较时：空数组 =&gt; &#39;&#39; =&gt; 0</li><li>判断、取反时：空数组 =&gt; true</li></ul><p>空对象{}：</p><ul><li>比较时：空对象 =&gt; &#39;[object Object]&#39; =&gt; NaN</li><li>判断时：true</li></ul><h2 id="_9-函数作用域、作用域链" tabindex="-1"><a class="header-anchor" href="#_9-函数作用域、作用域链" aria-hidden="true">#</a> 9 函数作用域、作用域链</h2><p><strong>作用域</strong>是当前的执行上下文，在其中的值和表达式“可见”（可被访问）。</p><p>JavaScript 的作用域分以下四种：</p><ul><li>全局作用域：脚本模式运行所有代码的默认作用域</li><li>模块作用域：模块模式中运行代码的作用域</li><li>函数作用域：由函数创建的作用域</li><li>块级作用域：用一对花括号创建出来的作用域，块级作用域只对 <code>let</code> 和 <code>const</code> 声明有效，对 <code>var</code> 声明无效。</li></ul><p>作用域链：当 JavaScript 使用每一个变量的时候，会先尝试在当前作用域中寻找该变量，若在当前的作用域找不到该变量，会一直往父层作用域寻找，直到全局作用域还是没找到，就会直接报错</p><p>问题：输出a为几？</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">}</span>
<span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果：报错 Cannot access &#39;a&#39; before initialization</p><p>注意：如果函数作用域里没有定义a变量，则输出全局作用域的a变量值1</p><h2 id="_10-不同的this指向情况" tabindex="-1"><a class="header-anchor" href="#_10-不同的this指向情况" aria-hidden="true">#</a> 10 不同的this指向情况</h2><ul><li>全局上下文中THIS指的是window[非严格模式] / undefined [ 严格模式（&#39;use strict&#39;）]</li><li>块级上下文、箭头函数中没有自己的THIS，它的THIS是继承所在上下文中的THIS</li><li>事件绑定、函数执行时 THIS 是调用方法的对象</li><li>构造函数体中的THIS是当前类的实例</li><li>call/apply/bind：修改this指向</li></ul><h2 id="_11-promise有哪些方法-promise-race方法介绍" tabindex="-1"><a class="header-anchor" href="#_11-promise有哪些方法-promise-race方法介绍" aria-hidden="true">#</a> 11 promise有哪些方法，promise.race方法介绍</h2><p>3个状态：<strong>pending、fulfilled、rejected</strong></p><p>九个方法：</p><ol><li>resolve：<strong>在执行了resolve后，</strong> promise则会从pedding变成 <strong>fulfilled</strong> ，后续会进入.then 的回调函数中，在回调函数的第一个参数函数中可以获取到值</li><li>reject：<strong>在执行了reject后</strong> ，promise状态会变成 <strong>rejected</strong> ，rejected函数传递的参数，可以在.then的第二个参数函数中获取得到，或者是在.catch获取到，<strong>---业务中，拒绝状态用.then去执行回调，异常用.catch</strong></li><li>then：函数回调执行，常用于接收请求接口返回的数据；该回调函数有两个参数（函数），一个是用于处理 Promise 解决时的回调函数，另一个是可选的用于处理 Promise 拒绝（rejected）时的回调函数；用于接收promise对应状态的数据。.then的返回值也是个promis对象</li><li>catch：用于注册在 Promise 对象拒绝（rejected）时的回调函数。同时也可以用来<strong>捕获代码异常</strong>或者出错</li><li>all：接收一个promise对象的数组（<strong>同时开始、并行执行</strong>）作为参数，当这个数组里面的promise对象，没有出现rejected状态，则会一直等待<strong>所有resolve成功</strong>后，才执行.then这个回调，如果有一个是rejected状态，则会先执行.all里面的.then中第二个回调函数或者.catch函数，不会等后续跑完再执行</li><li>any：接收一个promise的数组作为参数，只要 <strong>其中有一个 <code>Promise</code>成功执行</strong> ，就会返回已经成功执行的 <code>Promise</code>的结果； 若全部为rejected状态 ，则会到最后的promise执行完，全部的promise返回到异常函数中</li><li>race：接收一个可迭代promise对象的数组，<strong>当任何一个promise的状态先确定（拒绝或者成功），则会执行.race中的回调函数</strong></li><li>allsettled：<strong>等所有promise参数确定状态后，才会执行回调函数</strong></li><li>finally：用于清理和最终处理逻辑，不关心 Promise 的状态</li></ol><h2 id="_12-css设置哪些属性会导致重绘、回流-改变字体大小会导致重绘或回流吗" tabindex="-1"><a class="header-anchor" href="#_12-css设置哪些属性会导致重绘、回流-改变字体大小会导致重绘或回流吗" aria-hidden="true">#</a> 12 css设置哪些属性会导致重绘、回流，改变字体大小会导致重绘或回流吗</h2><p>重绘：当页面元素样式改变不影响元素在文档流中的位置时（如background-color，border-color，visibility），浏览器只会<strong>将新样式赋予元素并进行重新绘制</strong>操作。</p><p>回流：当渲染树render tree中的一部分或全部因为元素的规模尺寸、布局、隐藏等改变时，浏览器<strong>重新渲染部分DOM或全部DOM</strong>的过程</p><blockquote><p>回流必将引起重绘，而重绘不一定会引起回流</p></blockquote><p><img src="`+t+'" alt="1721740459058" loading="lazy"></p><p><img src="'+p+'" alt="1721740480112" loading="lazy"></p><h2 id="_13-浏览器从输入网址到页面渲染之间的过程" tabindex="-1"><a class="header-anchor" href="#_13-浏览器从输入网址到页面渲染之间的过程" aria-hidden="true">#</a> 13 浏览器从输入网址到页面渲染之间的过程</h2><ol><li><p>输入URL</p></li><li><p>查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。</p><ul><li>浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；</li><li>操作系统缓存: 如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；</li><li>路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；</li><li>ISP缓存：若上述均失败，继续向ISP搜索。</li></ul></li><li><p>DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。<code>DNS服务器是基于UDP的，因此会用到UDP协议</code>。</p></li><li><p>建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接</p></li><li><p>发起HTTP请求：浏览器发起读取文件的HTTP请求，该请求报文作为TCP三次握手的第三次数据发送给服务器</p></li><li><p>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器</p></li><li><p>关闭TCP连接：通过四次挥手释放TCP连接</p></li><li><p>浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：</p><ul><li>构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象</li><li>构建CSS规则树：生成CSS规则树（CSS Rule Tree）</li><li>构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）</li><li>布局（Layout）：计算出每个节点在屏幕中的位置</li><li>绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。</li></ul><p><img src="http://xlinwork.online:8001/assets/1716962809447-RFiAiRIJ.png" alt="1716962809447" loading="lazy"></p></li><li><p>JS引擎解析过程：调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</p><ul><li>创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。</li><li>加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译</li><li>预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为&#39;undefined&#39;；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。</li><li>解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。</li></ul></li></ol><h2 id="_14-强缓存和协商缓存区别" tabindex="-1"><a class="header-anchor" href="#_14-强缓存和协商缓存区别" aria-hidden="true">#</a> 14 强缓存和协商缓存区别</h2><p>强缓存：浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status Code: 200 OK</p><p>协商缓存: 向服务器发送请求，服务器通过请求头中的If-Modified-Since（Last-Modified）或者 If-None-Match（Etag）字段检查资源是否更新，更新则返回新资源和200，没有更新则返回304，告诉浏览器直接从缓存获取资源</p><h2 id="_15-协商缓存有哪些header做判断" tabindex="-1"><a class="header-anchor" href="#_15-协商缓存有哪些header做判断" aria-hidden="true">#</a> 15 协商缓存有哪些header做判断</h2><p>强制缓存：</p><p>在过期时间内则为强制缓存</p><ul><li>Expires：过期时间（http1.0）</li><li>Cache-Control：max-age=xxx 缓存有效时间（http1.1，会覆盖Expires）</li></ul><p>协商缓存：</p><p>条件：缓存过期Cache-Control：no-cache</p><ul><li>ETag/If-None-Match ：<code>ETag</code>是一个资源版本的唯一标识符，后续请求该资源时，会在请求头中携带 <code>If-None-Match</code>字段，其值为先前接收到的 <code>ETag</code>，服务器会根据这个值来判断资源是否有更新。（http1.1，优先级更高）</li><li>Last-Modified/If-Modified-Since：类似于 <code>ETag</code>机制，但 <code>Last-Modified</code>记录的是资源最后修改的时间。浏览器在后续请求时，会在请求头中携带 <code>If-Modified-Since</code>字段，其值为先前接收到的 <code>Last-Modified</code>时间。服务器会检查资源的最后修改时间是否在这个时间之后。（http1.0）</li></ul><p><img src="'+o+`" alt="1722668888130" loading="lazy"></p><h2 id="_16-get、post区别" tabindex="-1"><a class="header-anchor" href="#_16-get、post区别" aria-hidden="true">#</a> 16 get、post区别</h2><p>1.get请求一般是去取获取数据（其实也可以提交，但常见的是获取数据）； post请求一般是去提交数据。</p><p>2.get因为参数会放在url中，所以隐私性，安全性较差，请求的数据长度是有限制的， 不同的浏览器和服务器不同，一般限制在 2~8K 之间，更加常见的是 1k 以内； post请求没有长度限制，请求数据是放在body中。</p><p>3.get请求刷新服务器或者回退没有影响，post请求回退时会重新提交数据请求。</p><p>4.get请求可以被缓存，post请求不会被缓存。</p><p>5.get请求会被保存在浏览器历史记录当中，post不会。get请求可以被收藏为书签，因为参数就在url中，但post不能。它的参数不在url中。</p><p>6.get请求只能进行url编码（appliacation-x-www-form-urlencoded）,post请求支持多种（multipart/form-data等）。</p><p>深入理解：</p><ol><li>GET 和 POST都是http请求方式， 底层都是 TCP/IP协议；通常GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包（但firefox是发送一个数据包），</li><li>对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200 （返回数据）表示成功；而对于 POST，浏览器先发送 header，服务器响应 100， 浏览器再继续发送 data，服务器响应 200 （返回数据）。</li></ol><h2 id="_17-restful约定哪些场景需要用get-哪些需要用post-有了解过吗" tabindex="-1"><a class="header-anchor" href="#_17-restful约定哪些场景需要用get-哪些需要用post-有了解过吗" aria-hidden="true">#</a> 17 restful约定哪些场景需要用get，哪些需要用post，有了解过吗</h2><p>Representational State Transfer，简称REST，直译过来表现层状态转换，是一种软件架构风格、设计风格，提供了一组设计原则和约束条件</p><p>GET（SELECT）：从服务器取出资源（一项或多项）</p><p>POST（CREATE）：在服务器新建一个资源</p><p>PUT（UPDATE）：在服务器更新资源</p><p>DELETE（DELETE）：从服务器删除资源</p><h2 id="_18-前端跨域-出于什么原因-如何解决" tabindex="-1"><a class="header-anchor" href="#_18-前端跨域-出于什么原因-如何解决" aria-hidden="true">#</a> 18 前端跨域，出于什么原因，如何解决</h2><p>过程：跨域是浏览器拦截的行为，请求已经发送到后端，后端返回的响应数据被浏览器拦截</p><p>原因：浏览器同源策略，协议+域名+端口都要相同</p><p>解决：CORS、JSONP、Nginx代理、websocket协议</p><h2 id="_19-如果跨域-请求有没有发出" tabindex="-1"><a class="header-anchor" href="#_19-如果跨域-请求有没有发出" aria-hidden="true">#</a> 19 如果跨域，请求有没有发出</h2><p>浏览器会发出这个请求，但是它会拦载响应内容，如果发现响应header中&quot;Access-Control-Alow-Origin&quot;设置的允许访问的源没有包含当前源，则拒绝将数据返回给当前源</p><h2 id="_20-代码题" tabindex="-1"><a class="header-anchor" href="#_20-代码题" aria-hidden="true">#</a> 20 代码题</h2><p>给你一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。（解释：注意，要求返回第三大的数是指在所有不同数字中排第三大的数。）</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">max3value</span> <span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> max1 <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
  <span class="token keyword">let</span> max2 <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token keyword">let</span> max3 <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max1<span class="token punctuation">)</span><span class="token punctuation">{</span>
      max3 <span class="token operator">=</span> max2
      max2 <span class="token operator">=</span> max1
      max1 <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> max3 <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">?</span> max3 <span class="token operator">:</span> max1
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我的思路：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">max3</span> <span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> arr1 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>a<span class="token operator">-</span>b<span class="token punctuation">)</span>
  <span class="token keyword">let</span> arr2 <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> arr2<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">3</span> <span class="token operator">?</span> arr2<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">:</span> arr2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：</p><ol><li>sort 方法排序是按照 utf-16 码元值升序排序，eg：1，1000，2，……</li><li>用 Set 去重后还要通过 array.from() 转换为数组</li></ol><h2 id="_21-有什么想问的问题" tabindex="-1"><a class="header-anchor" href="#_21-有什么想问的问题" aria-hidden="true">#</a> 21 有什么想问的问题</h2><p>百度文库技术栈：vue2、vue3都在用，vue2项目升级工作量太大因此不升级</p>`,98),l=[c];function r(u,d){return s(),a("div",null,l)}const v=n(i,[["render",r],["__file","baidupre1.html.vue"]]);export{v as default};
