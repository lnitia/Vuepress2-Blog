import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as r,c as a,f as i}from"./app-0mkQjek1.js";const o={},d=i('<h1 id="华泰证券面经" tabindex="-1"><a class="header-anchor" href="#华泰证券面经" aria-hidden="true">#</a> 华泰证券面经</h1><h2 id="_1-自我介绍" tabindex="-1"><a class="header-anchor" href="#_1-自我介绍" aria-hidden="true">#</a> 1 自我介绍</h2><h2 id="_2-研究生小组周报办公系统负责内容" tabindex="-1"><a class="header-anchor" href="#_2-研究生小组周报办公系统负责内容" aria-hidden="true">#</a> 2 研究生小组周报办公系统负责内容</h2><p>前端 - vue2 + 后端 - nodejs</p><h2 id="_3-技术栈主要是vue还是react" tabindex="-1"><a class="header-anchor" href="#_3-技术栈主要是vue还是react" aria-hidden="true">#</a> 3 技术栈主要是vue还是react</h2><p>react</p><h2 id="_4-讲一下事件冒泡" tabindex="-1"><a class="header-anchor" href="#_4-讲一下事件冒泡" aria-hidden="true">#</a> 4 讲一下事件冒泡</h2><p><strong>事件冒泡</strong>：当一个元素接收到事件的时候，会把他接收到的事件传给自己的父级，一直到 <code>window</code> （注意这里传递的仅仅是事件，例如 <code>click、focus</code>等等这些事件， 并不传递所绑定的事件函数。）</p><p>eg：给三个盒子依次绑定点击事件，当点击盒子的时候，会依次触发父级元素的点击事件</p><p><strong>事件捕获</strong>：当鼠标点击或者触发 <code>dom</code>事件时（被触发 <code>dom</code>事件的这个元素被叫作事件源），浏览器会从根节点 =&gt;事件源（由外到内）进行事件传播</p><p>先事件捕获再事件冒泡</p><p><strong>事件委托</strong>：也称为 <code>事件代理</code>。就是利用 <code>事件冒泡</code>，把子元素的事件都绑定到父元素上。如果子元素阻止了事件冒泡，那么委托就无法实现。</p><h2 id="_5-addeventlistener是什么-接收几个参数" tabindex="-1"><a class="header-anchor" href="#_5-addeventlistener是什么-接收几个参数" aria-hidden="true">#</a> 5 addeventlistener是什么，接收几个参数</h2><p>事件监听器</p><p><code>element.addEventListener(event, function, useCapture)</code></p><p>event：不可省略。注意: 在 addEventListener() 方法中不能使用 &quot;on&quot; 前缀，会报错。 eg：要使用 &quot;click&quot; ,而不是 &quot;onclick&quot;。</p><p>function：不可省略。事件发生时运行的函数。</p><p>useCapture:可以省略，默认值是 false。true ：使用事件捕获，false ：使用事件冒泡</p><h2 id="_6-能改变原数组的值的方法" tabindex="-1"><a class="header-anchor" href="#_6-能改变原数组的值的方法" aria-hidden="true">#</a> 6 能改变原数组的值的方法</h2><p>7个：push、pop、shift、unshift、sort、reverse、splice(start, deleteCount, item1, item2)（区别于slice(start, end)）</p><h2 id="_7-怎么学习react的" tabindex="-1"><a class="header-anchor" href="#_7-怎么学习react的" aria-hidden="true">#</a> 7 怎么学习react的</h2><p>官方文档 - 视频 - 边看边做</p><h2 id="_8-学的过程中遇到什么困难-怎么解决的" tabindex="-1"><a class="header-anchor" href="#_8-学的过程中遇到什么困难-怎么解决的" aria-hidden="true">#</a> 8 学的过程中遇到什么困难，怎么解决的</h2><h2 id="_9-讲一下promise" tabindex="-1"><a class="header-anchor" href="#_9-讲一下promise" aria-hidden="true">#</a> 9 讲一下promise</h2><p><strong>介绍</strong>：是异步编程的一种解决方案， 它的构造函数是同步执行的，then 方法是异步执行的，所以Promise创建后里面的函数会立即执行，构造函数中的resolve和reject只有第一次执行有效，也就是说Promise状态一旦改变就不能再变</p><p><strong>作用</strong>：主要是用来解决回调地狱的问题，通过使用.then来使得代码成链式调用，方便维护和使用。.then中的回调函数属于异步任务中的微任务</p><p><strong>状态</strong>：promise一共有3个状态：pending、fulfilled和rejected</p><p>pedding-&gt;初始状态：调用promise时，一开始就呈现出等待状态，遇到resolve或者reject之前，都处于这个状态，且可以改变，但如果确定了状态（fulfilled/reject），则结果将永远不变，不能再次修改</p><p>fulfilled-&gt;成功状态：在执行了resolve后，promise则会从pedding变成fulfilled，后续会进入.then 的回调函数中，在回调函数的第一个参数函数中可以获取到值</p><p>rejected-&gt;失败状态：在执行了reject后，promise状态会变成rejected，rejected函数传递的参数，可以在.then的第二个参数函数中获取到，或者是在.catch获取到，但是如果程序上的错误，得通过.catch函数去拿到失败消息，在.then中是获取不了的</p><p><strong>九个方法</strong>：Promise.resolve，Promise.reject，Promise.then，Promise.catch，Promise.any，Promise.finally</p><ul><li><strong>Promise.all(promises)</strong>：接收一个包含多个Promise对象的数组，等待所有都完成时，返回存放它们结果的数组。如果任一被拒绝，则立即抛出错误，其他已完成的结果会被忽略</li><li><strong>Promise.allSettled(promises)</strong> : 接收一个包含多个Promise对象的数组，等待所有都已完成或者已拒绝时，返回存放它们结果对象的数组。每个结果对象的结构为 <code>{status:&#39;fulfilled&#39; // 或 &#39;rejected&#39;, value // 或reason}</code></li><li><strong>Promise.race(promises)</strong> : 接收一个包含多个Promise对象的数组，等待第一个有结果（完成/拒绝）的Promise，并把其result/error作为结果返回</li></ul><h2 id="_10-还有哪些异步方法" tabindex="-1"><a class="header-anchor" href="#_10-还有哪些异步方法" aria-hidden="true">#</a> 10 还有哪些异步方法</h2><p>回调函数、async/await、generator</p><h2 id="_11-nodejs环境和浏览器环境区别" tabindex="-1"><a class="header-anchor" href="#_11-nodejs环境和浏览器环境区别" aria-hidden="true">#</a> 11 nodejs环境和浏览器环境区别</h2><ol><li>在 Node.js 中没有浏览器提供的 <code>document</code>、<code>window</code> 和所有其他对象。在浏览器中，没有 Node.js 通过其模块提供的所有优秀 API，例如文件系统访问功能。</li><li>在 Node.js 中可以控制环境（nodejs版本）。可以支持的所有现代 ES2015+ JavaScript，而浏览器版本无法自由选择，可能只能使用较旧的 JavaScript / ECMAScript 版本，就需要通过 Babel 将代码转换为 ES5 兼容。</li><li>Node.js 同时支持 CommonJS 和 ES 模块系统。nodejs可以同时使用 <code>require()</code> 和 <code>import</code>，而在浏览器中只能使用 <code>import</code>。</li></ol><h2 id="_12-nodejs和浏览器不同的全局变量有哪些" tabindex="-1"><a class="header-anchor" href="#_12-nodejs和浏览器不同的全局变量有哪些" aria-hidden="true">#</a> 12 nodejs和浏览器不同的全局变量有哪些</h2><p>全局变量是全局对象的属性</p><p>nodejs</p><p>1、全局对象</p><ul><li>global：表示Node所在的全局环境，类似于浏览器中的window对象。</li><li>process：指向Node内置的process模块，允许开发者与当前进程互动。eg：在DOS或终端窗口直接输入node，就会进入NODE的命令行方式（REPL环境）。要退出的话，可以输入 process.exit()</li><li>console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。</li></ul><p>2、全局函数</p><ul><li>定时器函数：共有4个，分别是setTimeout(), clearTimeout(), setInterval(), clearInterval()</li><li>require()：用于加载模块</li></ul><p>3、全局变量：</p><ul><li>__filename：指向当前运行的脚本文件名。</li><li>__dirname：指向当前运行的脚本所在的目录。</li></ul><p>浏览器 - 全局对象为window</p><h2 id="_13-globol下面包括哪些东西" tabindex="-1"><a class="header-anchor" href="#_13-globol下面包括哪些东西" aria-hidden="true">#</a> 13 globol下面包括哪些东西</h2><ol><li>__dirname</li><li>__filename</li><li>exports</li><li>module</li><li>require()</li></ol><p>有些内置对象 是 JavaScript 语言本身的一部分，它们也可以全局地访问。</p><h2 id="_14-nodejs有一个处理二进制数据的是什么" tabindex="-1"><a class="header-anchor" href="#_14-nodejs有一个处理二进制数据的是什么" aria-hidden="true">#</a> 14 nodejs有一个处理二进制数据的是什么</h2><p>Buffer类：允许将原始二进制数据存储在内存中，并提供了一系列的方法来操作这些数据。例如，使用 <code>Buffer.from()</code>方法将字符串或数组转换为Buffer对象，使用 <code>Buffer.toString()</code>方法将Buffer对象转换为字符串或数组。此外，可以使用Buffer类来对二进制数据进行编码和解码操作。</p><h2 id="_15-express框架和koa框架区别" tabindex="-1"><a class="header-anchor" href="#_15-express框架和koa框架区别" aria-hidden="true">#</a> 15 express框架和koa框架区别</h2><p>Koa 是 Express 的轻量级版本。它是一个中间件框架，没有像 Express 那样的额外模块（比如，没有内置路由和模板引擎）。</p><h2 id="_16-express怎么部署的-一个实例还是多个实例" tabindex="-1"><a class="header-anchor" href="#_16-express怎么部署的-一个实例还是多个实例" aria-hidden="true">#</a> 16 express怎么部署的，一个实例还是多个实例</h2><p>一个实例</p><p>多个实例部署：不同的服务器或同一服务器的不同端口上运行多个 Express 实例</p><h2 id="_17-用户量问题-面对很多用户的时候怎么部署" tabindex="-1"><a class="header-anchor" href="#_17-用户量问题-面对很多用户的时候怎么部署" aria-hidden="true">#</a> 17 用户量问题，面对很多用户的时候怎么部署</h2><p>前端部署：</p><ol><li><strong>静态文件托管</strong> ：将前端项目构建为静态文件（HTML、CSS、JavaScript）。使用 CDN（内容分发网络）托管静态文件，以提高加载速度和可靠性。</li><li><strong>构建优化</strong> ：使用构建工具（如 Webpack、Parcel）对前端代码进行优化和压缩。启用代码拆分和懒加载，以减少初始加载时间。使用 Tree Shaking 和 Dead Code Elimination 减少包的大小。</li><li><strong>HTTP/2 和缓存</strong> ：启用 HTTP/2 协议，以提高传输效率。设置合理的缓存策略，使用 Cache-Control 和 ETag 头部，以减少重复加载。</li></ol><p>nodejs部署：多实例部署</p><h2 id="_18-nodejs是几个线程" tabindex="-1"><a class="header-anchor" href="#_18-nodejs是几个线程" aria-hidden="true">#</a> 18 nodejs是几个线程</h2><p>两种线程：<em>event loop</em> 处理的主线程和 <em>worker pool</em> 中的几个辅助线程。</p><p>事件循环是一种机制，它采用回调（函数）并注册它们，准备在将来的某个时刻执行。它与相关的 JavaScript 代码在同一个线程中运行。当 JavaScript 操作阻塞线程时，事件循环也会被阻止。</p><p>工作池是一种执行模型，它产生并处理单独的线程，然后同步执行任务，并将结果返回到事件循环。事件循环使用返回的结果执行提供的回调。</p><h2 id="_19-有了解哪些前端比较新的东西吗" tabindex="-1"><a class="header-anchor" href="#_19-有了解哪些前端比较新的东西吗" aria-hidden="true">#</a> 19 有了解哪些前端比较新的东西吗</h2><p>跨端 flutter，react native</p><p>ES新语法</p><h2 id="_20-了解到哪些es新语法" tabindex="-1"><a class="header-anchor" href="#_20-了解到哪些es新语法" aria-hidden="true">#</a> 20 了解到哪些ES新语法</h2><p>ES15（2024）</p><ol><li>Object.groupBy 分组</li><li>Promise.withResolvers 把 Promise实例、resolve、reject 解构出来供使用</li><li>String.prototype.isWellFormed、String.prototype.toWellForme测试字符串格式是否正确及转换为正确格式</li></ol><h2 id="_21-遇到的困难的问题-举个例子-怎么解决的" tabindex="-1"><a class="header-anchor" href="#_21-遇到的困难的问题-举个例子-怎么解决的" aria-hidden="true">#</a> 21 遇到的困难的问题，举个例子，怎么解决的</h2><h2 id="_22-有什么问题" tabindex="-1"><a class="header-anchor" href="#_22-有什么问题" aria-hidden="true">#</a> 22 有什么问题</h2><p>技术栈 - react多，vue也有用，用的是vue3</p>',73),t=[d];function s(n,l){return r(),a("div",null,t)}const p=e(o,[["render",s],["__file","huatai.html.vue"]]);export{p as default};
