import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as t,c as o,f as r}from"./app-0SoiKzJB.js";const i={},n=r('<h1 id="腾讯音乐一面" tabindex="-1"><a class="header-anchor" href="#腾讯音乐一面" aria-hidden="true">#</a> 腾讯音乐一面</h1><h2 id="_1-自我介绍" tabindex="-1"><a class="header-anchor" href="#_1-自我介绍" aria-hidden="true">#</a> 1 自我介绍</h2><h2 id="_2-针对青岛项目展开讲讲" tabindex="-1"><a class="header-anchor" href="#_2-针对青岛项目展开讲讲" aria-hidden="true">#</a> 2 针对青岛项目展开讲讲</h2><h2 id="_3-unity画面展示会不会有性能问题-有没有遇到渲染比较慢或卡顿问题-实时传输为什么没有卡顿呢" tabindex="-1"><a class="header-anchor" href="#_3-unity画面展示会不会有性能问题-有没有遇到渲染比较慢或卡顿问题-实时传输为什么没有卡顿呢" aria-hidden="true">#</a> 3 unity画面展示会不会有性能问题，有没有遇到渲染比较慢或卡顿问题，实时传输为什么没有卡顿呢</h2><p>Unity Render Streaming 在网页端展示时确实可能遇到性能问题，特别是在以下场景中：</p><ul><li><strong>网络带宽不足</strong> ：视频流的传输依赖网络带宽，如果带宽不足，可能导致画面延迟、卡顿。</li><li><strong>客户端性能</strong> ：客户端设备的性能较低时，解码视频流可能会较慢，导致画面不流畅。</li><li><strong>服务器负载</strong> ：如果多个用户同时连接同一个 Unity Render Streaming 服务器，服务器的负载过高，也可能导致流传输变慢。</li></ul><p><strong>实时传输没有卡顿</strong>的原因通常与以下因素有关：</p><ul><li><strong>WebRTC 技术</strong> ：Unity Render Streaming 基于 WebRTC 协议进行实时视频流传输，WebRTC 通过直接的点对点连接减少了延迟。</li><li><strong>视频编码优化</strong> ：使用 H.264 等高效视频编码格式，压缩传输的数据量，减少传输延迟。</li></ul><p>不过，在低带宽或高延迟网络环境下，仍可能出现渲染慢或卡顿问题。</p><h2 id="_4-有没有页面方面的性能问题-比如整个页面打开会比较慢" tabindex="-1"><a class="header-anchor" href="#_4-有没有页面方面的性能问题-比如整个页面打开会比较慢" aria-hidden="true">#</a> 4 有没有页面方面的性能问题，比如整个页面打开会比较慢</h2><ol><li>接收unity画面前会有几秒-十几秒钟的延迟，通过loading界面进行过渡</li><li>三维模型展示会延迟两秒左右，通过修改模型格式为二进制的glft格式进行优化，并将模型blob格式存到indexedDB中</li></ol><p>在大型项目中，页面性能问题可能会包括以下几种：</p><ul><li><strong>初次加载时间较长</strong> ：页面资源（如 JS、CSS、图片等）较大，导致页面打开速度慢。</li><li><strong>渲染阻塞</strong> ：JavaScript 脚本或 CSS 文件的加载可能会阻塞页面的渲染。</li><li><strong>资源请求数量过多</strong> ：过多的 HTTP 请求会增加页面加载时间，尤其是在带宽有限的情况下。</li></ul><p>为了解决这些问题，可以使用代码拆分、延迟加载资源（如懒加载图片）以及优化资源的大小和数量。</p><h2 id="_5-讲一下react怎么做双向数据绑定的" tabindex="-1"><a class="header-anchor" href="#_5-讲一下react怎么做双向数据绑定的" aria-hidden="true">#</a> 5 讲一下react怎么做双向数据绑定的</h2><p>React 不是默认双向数据绑定框架，通常是单向数据流</p><p>umi框架的数据管理采用的是umi提供的一个插件。</p><p>一种基于 <code>hooks</code> 范式的简易数据管理方案（部分场景可以取代 <code>dva</code>），通常用于中台项目的全局共享数据。</p><p>它约定在src/model文件夹中的文件为model文件。每个文件需要默认导出一个 function，该 function 定义了一个 Hook。就是自定义 <code>hooks</code> 模块。</p><p><code>@umijs/plugin-model</code> 把自定义hook里的状态变成了『全局状态』，多个组件中使用该 <code>model</code>文件 时，拿到的同一份状态。从而实现全局数据的管理。</p><ul><li><strong>基于 <code>React.Context</code> 创建一个全局的 <code>Context</code></strong>;</li><li><strong>使用 <code>Context.Provider</code> 包裹根组件，并执行所有的 <code>useModel</code> 对应的 <code>hooks</code></strong></li><li><strong>在 <code>useModel</code> 函数中通过 <code>useContext</code> 获取到 <code>dispatcher</code>, 并更新数据</strong></li></ul><h2 id="_6-有没有引入redux" tabindex="-1"><a class="header-anchor" href="#_6-有没有引入redux" aria-hidden="true">#</a> 6 有没有引入redux</h2><p>没有</p><p>Redux 是 React 生态中常用的状态管理库，用于在全局范围内管理应用的状态。它通过 <code>store</code> 保存状态，<code>action</code> 触发状态改变，<code>reducer</code> 负责状态更新。</p><h2 id="_7-讲一下周报系统" tabindex="-1"><a class="header-anchor" href="#_7-讲一下周报系统" aria-hidden="true">#</a> 7 讲一下周报系统</h2><h2 id="_8-网络请求是怎么走通的-是用的http还是https-为什么没有引入https" tabindex="-1"><a class="header-anchor" href="#_8-网络请求是怎么走通的-是用的http还是https-为什么没有引入https" aria-hidden="true">#</a> 8 网络请求是怎么走通的，是用的http还是https，为什么没有引入https</h2><ul><li><strong>HTTP</strong> 是一种无状态的协议，常用于简单的网络请求。</li><li><strong>HTTPS</strong> 是 HTTP 的加密版本，通过 SSL/TLS 协议加密数据传输，防止数据被中间人攻击或窃听。</li></ul><p>没有引入 HTTPS 的原因包括：</p><ul><li><strong>项目需求</strong> ：对于一些内网项目或对安全性要求较低的场景，可能没有引入 HTTPS。</li><li><strong>配置复杂度</strong> ：启用 HTTPS 需要服务器配置 SSL/TLS 证书，可能增加了项目的复杂性。</li></ul><h2 id="_9-http连接的三次握手四次挥手" tabindex="-1"><a class="header-anchor" href="#_9-http连接的三次握手四次挥手" aria-hidden="true">#</a> 9 http连接的三次握手四次挥手</h2><p><strong>三次握手</strong> ：建立连接的过程，确保客户端和服务器都准备好进行数据传输。</p><ol><li>客户端发送 SYN 包（请求建立连接）</li><li>服务器回复 SYN-ACK 包（同意建立连接）</li><li>客户端发送 ACK 包（确认连接建立）</li></ol><p><strong>四次挥手</strong> ：关闭连接的过程，确保双方都完成数据传输。</p><ol><li>客户端发送 FIN 包（请求关闭连接）</li><li>服务器回复 ACK 包（确认关闭请求）</li><li>服务器发送 FIN 包（请求关闭连接）</li><li>客户端发送 ACK 包（确认关闭）</li></ol><h2 id="_10-http相对于https有什么问题" tabindex="-1"><a class="header-anchor" href="#_10-http相对于https有什么问题" aria-hidden="true">#</a> 10 http相对于https有什么问题</h2><ul><li><strong>数据传输不安全</strong> ：HTTP 数据是明文传输，容易被中间人窃听或篡改。</li><li><strong>无法验证身份</strong> ：HTTP 无法确认服务器的真实性，容易遭受钓鱼攻击。</li></ul><h2 id="_11-https是怎么加密的" tabindex="-1"><a class="header-anchor" href="#_11-https是怎么加密的" aria-hidden="true">#</a> 11 https是怎么加密的</h2><p>HTTPS 通过 SSL/TLS 协议进行加密，主要包括以下步骤：</p><ol><li><strong>握手阶段</strong> ：客户端和服务器协商加密算法和会话密钥。</li><li><strong>公钥加密</strong> ：客户端使用服务器的公钥加密数据，只有服务器的私钥能解密。</li><li><strong>对称加密</strong> ：使用协商好的对称密钥加密通信内容。</li></ol><h2 id="_12-有没有了解请求报文和响应报文的内容" tabindex="-1"><a class="header-anchor" href="#_12-有没有了解请求报文和响应报文的内容" aria-hidden="true">#</a> 12 有没有了解请求报文和响应报文的内容</h2><p><strong>请求报文</strong> ：</p><ul><li>请求行：包含请求方法（GET、POST 等）、请求路径和协议版本。</li><li>请求头：包含请求的元数据，如 <code>User-Agent</code>、<code>Host</code>、<code>Accept</code> 等。</li><li>请求体：包含提交的数据（POST 请求时）。</li></ul><p><strong>响应报文</strong> ：</p><ul><li>状态行：包含协议版本、状态码和状态描述。</li><li>响应头：包含响应的元数据，如 <code>Content-Type</code>、<code>Content-Length</code>、<code>Set-Cookie</code> 等。</li><li>响应体：包含实际返回的数据。</li></ul><h2 id="_13-浏览器从输入url到显示界面的过程-渲染部分展开讲讲" tabindex="-1"><a class="header-anchor" href="#_13-浏览器从输入url到显示界面的过程-渲染部分展开讲讲" aria-hidden="true">#</a> 13 浏览器从输入url到显示界面的过程，渲染部分展开讲讲</h2><ul><li><strong>读缓存</strong></li><li><strong>DNS 解析</strong> ：将域名解析为 IP 地址。</li><li><strong>建立连接</strong> ：通过 TCP/IP 协议建立与服务器的连接。</li><li><strong>发送请求</strong> ：浏览器向服务器发送 HTTP/HTTPS 请求。</li><li><strong>服务器处理请求</strong> ：服务器处理请求并返回响应数据。</li><li><strong>浏览器接收响应</strong> ：浏览器接收并解析 HTML、CSS、JavaScript 等资源。</li><li><strong>页面渲染</strong> ：浏览器将解析的内容构建 DOM 树、CSSOM 树，然后生成渲染树，最后绘制页面。</li></ul><h2 id="_14-假如把js脚本放在html最前面加载会有什么问题-对页面性能方面有什么影响" tabindex="-1"><a class="header-anchor" href="#_14-假如把js脚本放在html最前面加载会有什么问题-对页面性能方面有什么影响" aria-hidden="true">#</a> 14 假如把js脚本放在html最前面加载会有什么问题，对页面性能方面有什么影响</h2><p>将 JS 脚本放在 HTML 头部可能导致以下问题：</p><ul><li><strong>阻塞渲染</strong> ：浏览器在加载和解析 JS 时，会阻塞 DOM 树的构建，导致页面渲染延迟。</li><li><strong>页面加载时间增加</strong> ：页面内容在 JS 加载完成前不会显示，用户体验变差。</li></ul><p>通常建议将 JS 脚本放在页面底部，或者使用 <code>defer</code> 和 <code>async</code> 属性进行优化。</p><h2 id="_15-有些业务必须在dom元素渲染前加载js脚本-有什么解决方法吗" tabindex="-1"><a class="header-anchor" href="#_15-有些业务必须在dom元素渲染前加载js脚本-有什么解决方法吗" aria-hidden="true">#</a> 15 有些业务必须在dom元素渲染前加载js脚本，有什么解决方法吗</h2><p>如果业务必须在 DOM 元素渲染前加载 JS 脚本，可以使用以下方法：</p><ol><li><code>&lt;script&gt;</code> <strong>标签的</strong> <code>async</code> <strong>或</strong> <code>defer</code> <strong>属性</strong> ：</li></ol><ul><li><code>async</code>：异步加载脚本，加载完立即执行，不阻塞页面渲染。</li><li><code>defer</code>：延迟执行脚本，等 DOM 解析完成后执行，不阻塞页面渲染。</li></ul><ol start="2"><li><strong>将关键的初始化代码内嵌在 HTML 中</strong> ，确保最小的 JS 逻辑在页面加载初期就能执行。</li></ol><h2 id="_16-服务端渲染的利弊-什么时候服务端渲染久一点-什么时候服务端渲染快一点-不是所有场景都能使用服务端渲染的-能举例吗" tabindex="-1"><a class="header-anchor" href="#_16-服务端渲染的利弊-什么时候服务端渲染久一点-什么时候服务端渲染快一点-不是所有场景都能使用服务端渲染的-能举例吗" aria-hidden="true">#</a> 16 服务端渲染的利弊，什么时候服务端渲染久一点，什么时候服务端渲染快一点，不是所有场景都能使用服务端渲染的，能举例吗</h2><p><strong>优点</strong> ：</p><ul><li><strong>SEO 友好</strong> ：搜索引擎可以抓取完整的 HTML 内容。</li><li><strong>首屏加载快</strong> ：HTML 内容在服务器端渲染，浏览器直接接收和渲染，减少客户端渲染的时间。</li></ul><p><strong>缺点</strong> ：</p><ul><li><strong>服务器负载高</strong> ：每次请求都需要服务器生成完整的页面，增加服务器压力。</li><li><strong>交互性差</strong> ：页面需要更多的 JS 逻辑来处理用户交互，可能需要额外的客户端渲染。</li></ul><p><strong>使用场景</strong> ：</p><ul><li><strong>服务端渲染适用场景</strong> ：内容需要快速展示，且对 SEO 友好，如博客、新闻网站。</li><li><strong>客户端渲染适用场景</strong> ：交互性强的单页应用，如仪表盘、管理后台。</li></ul><h2 id="_17-讲一下防抖和节流-使用场景" tabindex="-1"><a class="header-anchor" href="#_17-讲一下防抖和节流-使用场景" aria-hidden="true">#</a> 17 讲一下防抖和节流，使用场景</h2><ul><li><strong>防抖（Debounce）</strong> ：在事件触发后，只有在规定的时间内没有再次触发事件，才会执行一次处理函数。适用于输入框实时搜索等场景。</li><li><strong>节流（Throttle）</strong> ：在规定的时间内，事件触发后只能执行一次处理函数，适用于窗口缩放、滚动事件等高频触发的场景。</li></ul><h2 id="_18-this指向绑定的规则-箭头函数的this指向" tabindex="-1"><a class="header-anchor" href="#_18-this指向绑定的规则-箭头函数的this指向" aria-hidden="true">#</a> 18 this指向绑定的规则，箭头函数的this指向</h2><ul><li><strong>默认绑定</strong> ：函数独立调用时，<code>this</code> 指向全局对象（严格模式下为 <code>undefined</code>）。</li><li><strong>隐式绑定</strong> ：函数作为对象的方法调用时，<code>this</code> 指向该对象。</li><li><strong>显式绑定</strong> ：通过 <code>call</code>、<code>apply</code>、<code>bind</code> 明确指定 <code>this</code> 指向。</li><li><strong>new 绑定</strong> ：通过 <code>new</code> 关键字创建实例时，<code>this</code> 指向新创建的对象。</li></ul><p><strong>箭头函数的 <code>this</code> 指向</strong> ：箭头函数没有自己的 <code>this</code>，它的 <code>this</code> 继承自外层作用域。</p><h2 id="_19-js为什么是单线程的" tabindex="-1"><a class="header-anchor" href="#_19-js为什么是单线程的" aria-hidden="true">#</a> 19 js为什么是单线程的</h2><p>JavaScript 设计为单线程是因为它最初是作为浏览器中的脚本语言，用于处理用户交互和更新 DOM。如果是多线程，可能会导致多个线程同时修改 DOM，造成不可预期的结果。为了避免这种情况，JavaScript 选择了单线程模型，但通过事件循环和回调机制来处理异步操作</p><h2 id="_20-反问" tabindex="-1"><a class="header-anchor" href="#_20-反问" aria-hidden="true">#</a> 20 反问</h2><p>技术栈：</p><p>腾讯内部的跨端框架，基于react</p>',72),d=[n];function l(s,a){return t(),o("div",null,d)}const g=e(i,[["render",l],["__file","tengxunyingyue.html.vue"]]);export{g as default};
