---
icon: javascript
date: 2024-01-06
category:
  - 前端
  - js
tag:
  - 基础
order: 1
excerpt: <p>js基础知识汇总</p>
editLink: false
---
# JS基础

## 1 JS认知

### 1.1 JS组成

1. ECMAScript - JS语法
2. [DOM](/frontend/js/Web%20Api.html#_1-dom) - 页面文档对象模型
3. [BOM](/frontend/js/Web%20Api.html#_2-bom) - 浏览器对象模型

### 1.2 JS书写位置

1. 行内式
   * 将单行或少量代码写在HTML标签的事件属性中（以on开头的属性）
   * HTML中推荐使用双引号，JS中推荐使用单引号
2. 内嵌式 `<script></script>`
3. 外部式 `<script scr="main.js"></script>`

### 1.3 JS注释

1. 单行注释//（ctrl + /）
2. 多行注释/* */（shift + alt + a）

## 2 输入输出语句

### 2.1 alert

弹出警示框

语法 `prompt('弹出的语句')`

### 2.2 console

控制台输出，用于测试

语法 `console.log('输出的语句')`

### 2.3 dir

打印DOM返回的元素对象

语法 `console.dir(元素对象)`

### 2.4 prompt

弹出输入框

语法 `prompt('请用户输入的提示语句')`

框里输入的值接收为字符串类型

## 3 变量&常量、基本数据类型

用于存放数据，是内存中申请的一段空间

### 3.1 变量声明

#### 3.1.1 声明关键词

1. `var`：声明一个全局或局部变量，可选初始化一个值（不建议使用）
2. `let`：声明一个块作用域的局部变量，可选初始化一个值
3. `const`：声明一个块作用域的只读常量

#### 3.1.2 声明变量&初始化

1. `var 变量名 = 值`
2. `let 变量名 = 值`
3. `const 常量名 = 值`

#### 3.1.3 同时声明

```javascript
var 变量名1 = 值,
    变量2 = 值
```

#### 3.1.4 不声明直接赋值

`变量 = 值`，会创建一个未声明的全局变量，不建议使用

### 3.2 变量&常量命名规范

1. 以字母、下划线、美元符号开头，后续可以包含字母、数字、下划线
2. 严格区分大小写
3. 不能是关键字和保留字

### 3.3 基本数据类型

七种基本数据类型：

1. 数字（**Number**），整数、浮点数、NaN
2. 字符串（**String**）
3. 布尔值（**Boolean**）
4. **null**，特殊关键字，表示**没有对象**，代表一个空对象指针。因为js大小写敏感，所以 `null` 与 `Null`、`NULL`或变体完全不同
5. **undefined**，特殊关键字，表示**缺少值**
6. 任意精度的整数（**BigInt**），可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制
7. 代表（**Symbol**，在 ECMAScript 6 中新添加的类型）。一种实例是唯一且不可改变的数据类型

### 3.4 检测数据类型

`typeof 待检测变量`

## 4 数字型Number

数字类型可以用来保存整数和浮点数

### 4.1 数字型进制

1. 八进制：数字前+0
2. 16进制：数字前+0x

### 4.2 数字范围

1. 最大值1.79e+308
2. 最小值5e-324

### 4.3 特殊值

1. 无穷大：Infinity
2. 无穷小：-Infinity
3. 非数字：NaN

### 4.4 数字判断

`isNaN()`判断是不是非数字

### 4.5 其他类型转换成数字型

1. `parseInt(字符串型变量)`变为整型
2. `parseFloat(字符串型变量)`变为浮点型
   * parseInt和parseFloat会去除数字之后的字符串，但是不能去除数字之前的字符串
3. `Number(变量)`
4. 利用算术运算隐式转换为数字型

## 5 字符串型String

推荐使用单引号

### 5.1 字符串嵌套

外单内双进行嵌套

### 5.2 字符串转义符

1. 换行 `\n`
2. tab缩进 `\t`
3. 空格 `\b`

### 5.3 字符串的拼接

1. 用+拼接
   * 只要有一个部分是字符串，输出都是字符串，和其他数据类型没关系
   * 变量可以直接把内容拼接到字符串里
2. 模板字符串拼接

```
`string text ${变量} string text`
```

### 5.4 字符串常用方法

[字符串常用方法](https://www.runoob.com/jsref/jsref-obj-string.html)

1. 返回长度 `字符串.length`
2. 大小写转换 `字符串.toLowerCase()|字符串.toUpperCase()`
3. 分割字符串为字符串数组 字符串.split("分割的值")
4. 返回指定位置字符串内容 `字符串.charAt(位置索引)|字符串.substring(起始位置索引,结束位置索引)`
5. 返回指定字符在字符串中首次出现的位置 `字符串.indexOf(查找的字符,起始的位置)`
6. 判断子字符串的存在 `字符串.includes(子字符串)`

### 5.5 其他类型转换成字符串

1. `变量.toString()`
2. `String(变量)`函数强制转换
3. 加号拼接

### 5.6 字符串的不可变

* 指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间
* 因为字符串的不可变不要大量拼接字符串

## 6 布尔型Boolean

* true可以当1来看
* false可以当0来看

### 6.1 其他类型转换成布尔型

1. `Boolean(变量)`
2. 代表空的''|0|NaN|null|undefined转换成false
3. 其他都是true

## 7 运算符

### 7.1 算数运算符

![算数运算符汇总.jpg](https://i.loli.net/2020/12/16/jHzUZP3Vwav6iLk.jpg)

* 浮点数存在阶段误差，不要判断浮点数是否相等
* 算数运算符的优先级和平时一样

### 7.2 递增递减运算符

1. `++`递增，每次加1
2. `--`递减，每次减1
3. 前置递增|递减：运算符在变量前面，先计算后输出
4. 后置递增|递减：运算符在变量后面，先输出后计算

```javascript
var age = 10
console.log(++age + 10); //输出21，前置递增
age = 10
console.log(age++ + 10); //输出20，后置递增
// 但是两个age都是11
```

### 7.3 比较运算符

![比较运算符汇总.jpg](https://i.loli.net/2020/12/16/ZxR1udmONy3jor5.jpg)

* `==`比较的时候会自动转换数据类型
* `===`同时要求值和数据类型

```javascript
console.log(18 == '18'); //true
console.log(18 === '18'); //false
```

### 7.4 逻辑运算符

![逻辑运算符汇总.jpg](https://i.loli.net/2020/12/16/cSAE8t6PZHRnlYy.jpg)

短路运算：当有多个表达式时，左边表达式可以确定结果后就不再进行右边的运算

#### 7.4.1 &&断路

`表达式1 && 表达式2`

* 表达式1真，返回表达式2
* 表达式1假，返回表达式1

#### 7.4.2 ||断路

`表达式1 || 表达式2`

* 表达式1真，返回表达式1
* 表达式1假，返回表达式2

### 7.5 赋值运算符

![赋值运算符汇总.jpg](https://i.loli.net/2020/12/16/hXMkOCN9quIDUjG.jpg)

### 7.6 运算符优先级

![运算符优先级.jpg](https://i.loli.net/2020/12/16/IFoSA4dx8q5BlJ2.jpg)

## 8 流程控制

### 8.1 顺序流程控制

### 8.2 分支流程控制

#### 8.2.1 if

```javascript
if (条件表达式) {
    条件成立时的执行语句
}
```

#### 8.2.2 if-else双分支

```javascript
if (条件表达式) {
    条件成立时的执行语句
} else{
    条件不成立时的执行语句
}
```

* if和else里只有一个语句能执行

#### 8.2.3 多分支语句

```javascript
if (条件表达式1) {
    条件1成立时的执行语句
} else if (条件表达式2){
    条件1不成立条件3成立时的执行语句
} else{
    所有条件都不成立时的执行语句
}
```

#### 8.2.4 三元表达式

1. 语法结构 `条件表达式 ? 表达式1 : 表达式2`
2. 执行思路
   * 条件表达式真，返回表达式1
   * 条件表达式假，返回表达式2

#### 8.2.5 switch

```javascript
switch (表达式) {
    case value1:
        表达式与value1匹配时的执行语句;
        break;
    case value2:
        表达式与value2匹配时的执行语句;
        break;
    default:
        都不满足时的执行语句;
}
```

* 匹配的要求是值和数据类型都相等才算匹配
* 要写break，否则switch会认为一直是匹配上的直接执行后续case的执行语句

### 8.3 循环流程控制

#### 8.3.1 for循环

```javascript
for (初始化变量;条件表达式；操作表达式) {
    循环体
}
```

#### 8.3.2 while循环

```javascript
while (条件表达式) {
    循环体
}
```

#### 8.3.3 do-while循环

```javascript
do {
    循环体
} while (条件表达式)
```

* 先执行循环体再判断条件

#### 8.3.4 continue

* 立即跳出本次循环，继续下一次循环

#### 8.3.5 break

* 立即跳出整个循环

## 9 数组Array

### 9.1 创建数组

#### 9.1.1 new关键字创建数组

`const 数组名 = new Array()`

* 通过实例化Array构造对象创建
* `const 数组名 = new Array(n)`创建长度为n的空数组
* `const 数组名 = new Array(1,2,3)`创建[1,2,3]数组

#### 9.1.2 利用数组字面量创建数组

`const 数组名 = []`

* 数组字面量[]
* 数组里的数据用逗号分隔
* 数组里的数据称为数组元素

### 9.2 数组索引

* 索引（下标）：用来访问数组元素的序列，从0开始
* 通过索引号访问数组元素 `数组名[索引号]`
* 没有数组元素，访问结果为undefined

### 9.3 数组长度

`数组名.length`

### 9.4 检测是否为数组

#### 9.4.1 instanceof 运算符

语法 `待检测内容 instanceof Array`

#### 9.4.2 .isArray()

语法 `Array.isArray(待检测内容)`

* ie9以上版本才支持

### 9.5 添加数组元素

#### 9.5.1 修改length长度

`数组名.length = 5`

添加空元素

#### 9.5.2 增加索引号

`数组名[索引号] = 新加元素`

追加元素

#### 9.5.3 .push()

 `数组.push(添加的元素)`

* 在尾部添加一个或多个数组元素
* push完后返回的是新数组的长度

#### 9.5.4 .unshift()

 `数组.unshift(添加的元素)`

* 在开头添加一个或多个数组元素
* unshift完后返回的是新数组的长度

### 9.6 删除数组元素

#### 9.6.1 .pop()

`数组.pop()`

* 删除数组最后的一个元素，一次只能删除一个元素
* pop完后返回被删除的元素

#### 9.6.2 .shift()

`数组.shift()`

* 删除数组第一个元素，一次只能删除一个元素
* shift完后返回被删除的元素

### 9.7 数组排序

#### 9.7.1 .reverse()

`数组.reverse()`

* 翻转数组

#### 9.7.2 .sort()

`数组.sort()`

* 冒泡排序
* 将元素转换为字符串，然后按照它们的 UTF-16 码元值升序排序
* 可以传入其他排序函数
* 返回对相同数组的引用

### 9.8 数组索引

#### 9.8.1 .indexOf()

`数组名.indexOf(元素名)`

* 查找数组中给定元素的第一个索引
* 不存在返回-1

#### 9.8.2 .lastIndexOf()

`数组名.lastIndexOf(元素名)`

* 查找数组中给定元素的最后一个索引
* 不存在返回-1

### 9.9 数组转换成字符串

#### 9.9.1 .toString()

* 把数组转换成字符串，逗号分隔每一项

#### 9.9.2 .join('分隔符')

* 把数组中的所有元素转换为一个字符串
* 分隔符默认为逗号

### 9.10 数组连接&切割

#### 9.10.1 .concat()

* 连接两个或多个数组
* 返回新数组
* 不影响原数组

#### 9.10.2 .slice()

`数组名.slice(开始索引,结束索引)`

* 分割数组
* 开始索引和结束索引可选
* 返回新数组
* 不影响原数组

#### 9.10.3 .splice()

```javascript
splice(start)//从start位置删除后面所有元素
splice(start, deleteCount)//从start位置删除指定数量元素
splice(start, deleteCount, item1)
splice(start, deleteCount, item1, item2, itemN)//从start位置删除指定数量元素并新增item1-itemN。若删除0个则直接新增item
```

* 删除or/and添加数组内指定位置元素
* 返回修改后的新数组
* 会影响原数组

### 9.11 数组遍历

#### 9.11.1 for of（ES6）

`for(let value of 数组名){}`

* 得到数组的每个值

for of与for in区别：

`for(let key in 数组名){}`

* `for of`遍历的是数组元素值， `for in`遍历的是数组的索引（即键名）
* `for of`适用遍历数/数组/字符串/`map`/`set`等拥有迭代器对象（`iterator`）的集合，但是不能遍历对象
* `for in`更适合遍历对象，也可以遍历数组，只遍历可枚举属性

#### 9.11.2 .forEach()

 `数组名.forEach(function(value,index,array){})`

* value：数组当前项的值
* index：数组当前项的索引
* array：被遍历的数组本身
* 在forEach里面return不会终止迭代

#### 9.11.3 .map()

`数组名.map(function(){})`

* 为数组中的每个元素执行一次函数
* 返回执行函数后的新数组

#### 9.11.4 .filter()

 `数组名.filter(function(value,index,array){})`

* 通过检测指定数组中符合条件的所有元素来筛选数组
* 返回筛选后得到的新数组

```javascript
const words = ['spray', 'elite', 'exuberant', 'destruction', 'present'];
const result = words.filter((word) => word.length > 6); //Array ["exuberant", "destruction", "present"]
```

#### 9.11.5 .some()

`数组名.some(function(value,index,array){})`

* 用于检测数组中元素是否满足指定条件
* 返回的是一个布尔值。如果查到这个元素，就返回true；如果查不到就返回false
* 如果找到第一个满足条件的元素，则终止循环，不再继续查找
* 在some里面return true会终止迭代

#### 9.11.6 .every()

`数组名.every(function(value,index,array){})`

* 遍历数组中所有元素，确认是否满足指定条件
* 返回的是一个布尔值。如果所有元素都满足返回true；如果有元素不满足就返回false
* 如果找到第一个不满足条件的元素，则终止循环，不再继续查找

## 10 函数

函数：封装了可被调用实行的代码块

### 10.1 函数的使用

#### 10.1.1 声明函数

##### 利用函数关键字声明（命名函数）

 `function 函数名(形参){}`

* function是声明函数的关键字
* 函数名一般是动词

##### 函数表达式声明（匿名函数）

 `let 变量名 = function(形参){}`

##### 箭头函数（ES6）

`const 函数名 = (形参) => {}`

* 一行代码可以省略“{}”，此时return也必须省略
* 只有一个形参时可以省略“()”

##### 通过[构造函数](#_20-构造函数和原型)声明

```javascript
function 构造函数名(形参){
  this.属性名(形参) = 值(实参);
  this.方法1 = function(){}
}
构造函数名.prototype.方法2 = function(){}//将不变的方法定义在prototype对象上

const 函数名 = new 构造函数名('实参')
函数名.方法1()
```

* 所有函数都是构造函数的实例化对象

#### 10.1.2 调用函数

##### 普通函数

1. `函数名()`
2. `函数名.call()`

##### 对象里的方法

`对象.函数名()`

##### 构造函数

 `new 构造函数名()`

##### 绑定事件函数

* 触发事件自动调用

##### 定时器函数

* 定时器自动调用

##### 立即执行函数

`(function(){})()`自动调用

### 10.2 函数的参数

#### 10.2.1 形参

函数声明的是形参

语法 `function 函数名(形参1,形参2){}`

* 是一种不用声明的变量
* 形参可以设置默认值，不赋值时默认为undefined

#### 10.2.2 实参

调用函数的是实参

语法 `函数名(实参1,实参2);`

#### 10.2.3 实参形参的关系

* 形参接受实参的数值
* 形参和实参可以不匹配
* 实参个数多于形参个数，后面的实参直接抛弃

### 10.3 函数返回

 `return 需要返回的结果;`

* return具有终止函数的功能
* return只能返回一个值，如果多个值返回最后一个值
* 函数如果没有return，则返回undefined

### 10.4 arguments

arguments是当前函数的内置对象，存储了传递的所有实参

语法

```javascript
function 函数名(){
    console.log(arguments)
    }
```

* arguments展示形参为一个伪数组
  * 可以遍历
  * 具有length属性
  * 按索引方式储存数据
  * 不具有数组的push、pop等方法
* 只有函数有arguments对象

### 10.5 函数的this

* this的指向是当我们调用函数的时候确定的
* 一般指向调用者
* 构造函数里的this和构造函数原型对象里的this都指向生成的实例对象

#### 10.5.1 call()

1. 可以调用函数，也可以改变this指向
2. 语法 `函数名.call(this指向,实参)`
3. 主要作用是实现继承。在子构造函数里用call调用父构造函数 `父构造函数名.call(this,参数)`

#### 10.5.2 apply()

1. 可以调用函数，也可以改变this指向
2. 语法 `函数名.apply(this指向,[实参])`（！实参的传递必须使用数组的方式）
3. 可以实现数组最大最小值 `Math.max.apply(Math,数组)`

#### 10.5.3 bind()

1. 不会调用函数，但能改变函数内部this指向
2. 语法 `函数名.bind(this指向,实参)`
3. 返回由指定的this值和初始化参数改造的原函数拷贝
4. 应用场景：有的函数不需要立即调用，但又想改变函数内部this指向

### 10.6 高阶函数

高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出

## 11 作用域

### 11.1 作用域概述

* 作用域：限定代码中用到的名字可用性的代码范围
* 作用域的目的是提高程序的可靠性，减少命名冲突
* 作用域分为全局作用域和局部作用域
  * 全局作用域：整个scrip标签或者一个单独的js文件
  * 局部作用域：只在函数内部，也可以叫做函数作用域
* 不同作用域下命名不冲突

### 11.2 变量的作用域

#### 11.2.1 全局变量

1. 在全局作用域下的变量
2. 在函数内部不声明直接赋值的变量也是全局变量

#### 11.2.2 局部变量

* 在局部作用域下的变量
* 只能在函数内部使用
* 函数的形参也可以看作局部变量

#### 11.2.3 全局效率

* 全局变量只有浏览器关闭的时候才会销毁，比较占内存资源
* 局部变量程序执行完毕就会销毁，比较节约内容资源

### 11.3 块级作用域

* 在es6新增了块级作用域
* 块级作用域：用{}包含的

### 11.4 作用域链

* 内部函数访问外部函数的变量采取的是链式查找的方式来决定是哪个值
* 作用域链：这种链式查找方式结构
* 就近原则

## 12 闭包

### 12.1 变量作用域

* 函数内部可以使用全局变量
* 函数外部不可以使用局部变量
* 当函数执行完毕，本作用域内的局部变量会销毁

### 12.2 闭包定义

* 闭包(closure)指有权访问另一个函数作用域中变量的函数

### 12.3 闭包作用

* 延伸了变量的作用范围

## 13 拷贝

1. 浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用，只拷贝地址
2. 深拷贝拷贝多层，每一个级别的数据都会拷贝

### 13.1 浅拷贝

* ES6新语法 `Object.assign(用于存储的变量名,被拷贝的变量名)`

### 13.2 深拷贝

* 通过递归函数来进行深拷贝

```javascript
function deepCopy(newObj,oldObj){
    for(var k in oldObj){
        var item = oldObj[k];
        if(item instanceof Array){
            newObj[k] = [];
            deepCopy(newObj[k],item);
        }else if(item instanceof Object){
            newObj[k] = {};
            deepCopy(newObj[k],item);
        }else{
            newObj[k] = item;
        }
    }
}
```

## 14 预解析

### 14.1 JS代码运行

* 预解析：js引擎会把里面所有的var还有function提升到当前作用域的最前面
* 代码执行：按照代码书写的顺序从上往下执行

### 14.2 变量预解析

* 变量预解析又叫变量提升
* 只提升变量声明不提升赋值操作

### 14.3 函数预解析

* 函数预解析又叫函数提升
* 只提升函数声明不调用
* 函数预解析只适用于用函数关键字声明的情况

## 15 对象

* 对象是一组无序的相关属性和方法的集合
* 属性：事物的特征
* 方法：事物的行为

### 15.1 创建对象

#### 15.1.1 利用字面量创建对象

```javascript
const obj = {
    //属性
    uname = 'qww', 
    //方法
    sayHi : function(){
        console.log('hi');
    }
}
```

* 对象字面量为{}
* 里面的属性或者方法采取键值对的形式
* 多个属性或者方法中间用逗号隔开
* 方法后面跟的是一个匿名函数
* 可以嵌套对象

#### 15.1.2 利用new Object创建对象

```javascript
const obj = new Object();
obj.uname = 'qww';
obj.sayHi = function(){
    console.log('hi');
}
```

* 利用等号赋值的方法添加对象的属性和方法

#### 15.1.3 利用[构造函数](#_20-构造函数和原型)创建对象

* 构造函数：把对象里相同的属性和方法抽象出来封装到函数里面
* 语法规范

```javascript
function 构造函数名() {
    this.属性 = 值;
    this.方法 = function(){}
}
new 构造函数名();
```

* 利用构造函数创建对象的过程也叫对象的实例化

### 15.2 使用对象

#### 15.2.1 调用对象属性

1. `对象名.属性名`
2. `对象名['属性名']`

#### 15.2.2 调用对象方法

`对象名.方法名()`

* 不能忘记添加小括号

#### 15.2.3 对象的解构（ES6）

`const { 属性名1，属性名2 } = 对象名`

* 解构后的属性不用带对象名直接使用

### 15.3 对象转换为JSON格式

`JSON.stringify(对象名)`

* 转换后的JSON字符串中属性名和字符串都会用双引号包裹

### 15.4 遍历对象 for in

* for in语句可以对数组或者对象的属性进行循环操作
* 语法

```javascript
for (let k in obj) {
    console.log(k); //输出的是属性名
    console.log(obj[k]); //输出的属性值
}
```

### 15.5 ES5新增方法

#### 15.5.1 Object.definerProperty()

1. 定义对象中新属性或修改原有的属性
2. 语法 `Object.definerProperty(目标对象,属性名,descriptor)`
3. descriptor表示目标属性所拥有的特性，需要以对象形式书写
4. descriptor四个属性
   * value：设置属性的值，默认为undefined
   * writable：值是否可以重写，默认为false
   * enumerable：目标属性是否可以被枚举，默认为false，不允许该属性被遍历出来
   * configurable：目标属性是否可以被删除或是否可以再次修改特性，默认为false

## 16 内置对象

JS中对象分成3种：自定义对象、内置对象、浏览器对象

* 内置对象：JS语言自带的一些对象，供开发者使用，并提供了一些常用的或是最基本的必要功能（属性和方法）

### 16.1 Math内置对象

Math不是一个函数对象，不是一个构造器，不需要new来调用，而是直接使用

#### 16.1.1 Math常用属性和方法

1. `Math.PI`圆周率
2. `Math.floor()`向下取整
3. `Math.ceil()`向上取整
4. `Math.round()`四舍五入，就近取整，-3.5取-3
5. `Math.abs()`绝对值，可以隐式转换，会把字符串转换成数字型
6. `Math.max/min()`最大、最小值
7. `Math.random()`0~1的随机数

### 16.2 日期内置对象

Date实例用来处理日期和时间，是一个构造函数，必须使用new调用

#### 16.2.1 使用Date

* 语法 `var date = new Date()`
* 如果没有参数返回系统的当前时间

#### 16.2.2 参数常用写法

1. 数字型 `2021,03,09`
2. 字符串型 `'2021-03-09 16:58:10'` 常用

#### 16.2.3 日期格式化

![日期格式化方法.jpg](https://i.loli.net/2021/03/09/9SXKFgviL7lpceA.jpg)

* 月份返回的会小1个月
* 返回星期的时候，周日返回的是0

#### 16.2.4 获取时间戳

时间戳是距离1970年1月1日的总毫秒数

1. `Date.valueOf()`
2. `Date.getTime()`
3. 可简化为 `var date1 = +new Date();`，最常用的写法
4. H5新增的方法 `Date.now()`

## 17 基本包装类型

基本包装类型就是把简单数据类型包装成为了复杂数据类型，使得简单数据类型有了属性和方法

* 过程：
  * 把简单数据类型包装为复杂数据类型
  * 把临时变量的值给str
  * 销毁临时变量
* 为了方便操作基本数据类型，JavaScript提供了三个特殊的引用类型：String、Number和Boolean

## 18 数据类型

### 18.1 堆和栈

其实JavaScript中没有堆和栈的概念，但可以方便理解代码的执行方式

#### 18.1.1 栈（操作系统）

* 由操作系统自动分配释放存放函数的参数值、局部变量的值等
* 其操作方式类似于数据结构中的栈
* 简单数据类型存放在栈里面

#### 18.1.2 堆（操作系统）

* 存储复杂类型（对象）
* 一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收

### 18.2 简单数据类型

1. 简单数据类型又叫作基本数据类型或者值类型
2. 值类型：在存储时变量中存储的是值本身
3. string、number、boolean、undefined、null
4. 简单数据类型null返回的是一个空对象

#### 18.2.1 简单数据类型内存分配

简单数据类型存放在栈里面，里面直接开辟一个空间存放的是值

### 18.3 复杂数据类型

* 复杂数据类型又叫引用类型
* 通过new关键字创建的对象（系统对象、自定义对象），如Object、Array、Date等

#### 18.3.1 复杂数据类型内存分配

* 复杂数据类型首先在栈里存放地址，16进制
* 然后栈中的地址指向堆里的数据

## 19 面向对象

### 19.1 面向对象编程介绍

1. 面向过程，POP(Process-oriented programming)。
   * 分析出解决问题所需的步骤，然后用函数把步骤一步步实现，使用的时候再一个个依次调用
   * 分析好步骤，按照步骤解决问题
2. 面向对象，OOP(Object Oriented Programming)
   * 把事务分解成为一个个对象，然后由对象之间分工与合作
   * 以对象功能划分问题，而不是步骤
   * 特点：
     * 封装性
     * 继承性
     * 多态性
3. 两者对比
   * 面向过程
     * 优点：性能比面向对象高，适合跟硬件联系很紧密的东西
     * 缺点：没有面向对象易维护、易复用、易扩展
   * 面向对象
     * 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活
     * 缺点：性能比面向过程低

### 19.2 ES6中的类和对象

#### 19.2.1 面向对象的思维特点

1. 抽取（抽象）对象共用的属性和行为组织（封装）成一个类（模板）
2. 对类进行实例化，获取类的对象

#### 19.2.2 对象

* 对象是一个具体的事物
* 在JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象
* 对象由属性和方法组成
  * 属性：事物的特征，在对象中用属性来表示
  * 方法：事物的行为，在对象中用方法来表示

#### 19.2.3 类class

* ES6中新增了类的概念，可以使用class关键字声明一个类，之后以这个类来实例化对象
* 类抽象了对象的公共部分，泛指某一大类
* 对象特指某一个，通过类实例化一个具体的对象

#### 19.2.4 创建类

* 创建类 `class 类名{类内容}`，类名习惯首字母大写
* 创建实例 `const 对象名 = new 类名()`，类必须使用new实例化对象

#### 19.2.5 类constructor构造函数

* constructor()方法是类的构造函数，用于传递参数，返回实例对象
* 通过new命令生成对象实例，自动调用该方法
* 如果没有显示定义，类内部会自动给我们创建一个constructor()
* 语法

```javascript
class 类名 {
    constructor(){
        this.属性名 = 值
    }
    方法名(){}
}
```

* 构造函数不需要加function

#### 19.2.6 类添加方法

* 把方法直接写在类里面即可
* 类里面所有的函数不需要function
* 在类里面所有函数之间不需要添加逗号

#### 19.2.7 类的继承

* 子类可以继承父类的属性和方法
* 语法 `class 子类名 extends 父类名{}`
* 继承中存在就近原则，子类有的方法直接调用，没有再去查找父类

##### super关键字

* 用于访问和调用对象父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数
* 语法 `super()`调用父类construction构造函数
* 语法 `super.父类方法()`调用父类的函数函数
* super()必须在子类this之前调用

#### 19.2.8 注意点

* 在ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象
* 类里共有的属性和方法一定要加this使用
* 类中this指向问题
  * 在construction里面的this指向实例对象
  * 方法里面的this指向这个方法的调用者

## 20 构造函数和原型

**面试重点**

### 20.1 构造函数

构造函数是一种特殊的函数，主要用来创建某一类对象

* 构造函数名的首字母大写
* 构造函数要和new一起使用才有意义
* new在执行时会做

  1. 在内存中创建一个新的空对象
  2. 让this指向这个新的对象
  3. 执行构造函数里面的代码，给这个新对象添加属性和方法
  4. 返回这个新对象（所以构造函数里面不需要return）
* 成员：构造函数中的属性和方法

  * 静态成员：在构造函数本身上添加的成员，只能由构造函数本身来访问。
  * 实例成员：在构造函数内部通过this添加的对象成员，只能由实例化的对象来访问。
* 构造函数存在内存浪费的问题，创建对象的时候会额外开辟空间以存放方法，且各对象同一方法不存放在一起，因此属性写在构造函数体内，但方法最好写在构造函数的原型上

### 20.2 构造函数原型 prototype

* JavaScript规定，每一个构造函数都一个prototype属性，指向另一个对象。这个对象的所有属性和方法都会被构造函数所拥有
* 我们可以把不变的方法直接定义在prototype对象上，这样所有的实例就可以共享这些方法

### 20.3 对象原型__proto__

* 对象都会有一个属性__proto__指向构造函数的prototype原型对象，这让对象可以使用构造函数原型对象的属性和方法
* 对象的__proto__对象原型和构造函数的prototype原型对象是一样的
* __proto__是一个非标准属性，不能对其赋值
* 对象方法查找规则
  1. 先查找对象是否存在该方法，有就执行对象上的方法
  2. 通过__proto__去构造函数原型对象里查找执行

### 20.4 构造函数constructor

* 对象原型__proto__和构造函数prototype原型对象里面都有一个属性constructor，被称为构造函数，因为它指回构造函数本身
* constructor用于记录该对象引用哪个构造函数，它可以让原型对象重新指向原来的构造函数
* 如果修改了原来的原型对象，给原型对象赋值的是一个对象，则必须手动地使用constructor指回原来的构造函数

### 20.5 构造函数、实例、原型对象三者之间的关系

![三角关系](https://pic.imgdb.cn/item/60b5eedd39f6859bc24afce3.jpg)

### 20.6 原型链

![原型链](https://pic.imgdb.cn/item/60b5f00039f6859bc25941ae.jpg)

### 20.7 成员的查找机制

1. 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性
2. 如果没有就查找它的原型（也就是__proto__指向的prototype原型对象）
3. 如果还没有就查找原型对象的原型（Object的原型对象）
4. 依次类推直到找到Object为止（null）

### 20.8 原型对象this指向

* 在构造函数中this指向对象实例
* 原型对象里的this指向对象实例

### 20.9 扩展内置对象

* 通过原型对象，对原来的内置对象进行扩展自定义的方法
* 数组和字符串内置对象不能给原型对象覆盖操作 `Array.prototype = {}`，只能是 `Array.prototype.XXX = function(){}`的方式

## 21 继承

1. ES6之前没有给我们提供extends继承。通过构造函数+原型对象模拟实现继承，被称为**组合继承**

### 21.1 call()

* 调用这个函数，并且修改函数运行时的this指向
* 语法 `func.call(thisArg, arg1, arg2, ...)`
  * thisArg：当前调用函数this的指向对象
  * arg1等：传递的其他参数

### 21.2 借用构造函数继承父类型属性

* 核心原理：通过call()把父类型的this指向子类型的this，这样就可以实现子类型继承父类型的属性
* 语法

```javascript
//借用父构造函数继承属性
function Father(uname, age) {
    //此处的this指向父构造函数的对象实例
    this.uname = uname;
    this.age = age;
}
function Son(uname, age) {
    //将父构造函数的this改成子构造函数的this
    Father.call(this, uname, age);
}
```

### 21.3 借用原型对象继承父类型方法

* 继承方法不能通过赋值原型对象的方法实现，这样会导致本来只打算在子类型上新定义的方法会同步到父类型上
* 语法

```javascript
//借用父构造函数继承属性
function Father() {
}
Father.prototype.money = function(){
    console.log(100000)
}
Son.prototype = new Father();
//如果利用对象的形式修改了原型对象，要用constructor指回原来的构造函数
Son.prototype.constructor = Son;
function Son() {
}
```

### 21.4 类的本质

1. class的本质还是一个函数，就是构造函数的另一种写法
2. 类有原型对象prototype
3. 类的原型对象prototype里有constructor指向类本身
4. 类可以通过原型对象的方式添加方法
5. 类创造的实例对象有__proto__指向类的原型对象
6. ES6类其实就是语法糖，简单写法实现相同功能

## 22 严格模式

* strict mode，ES5的严格模式是采用具有限制性JavaScript变体的一种方式
* 严格模式作用
  1. 消除了JavaScript语法的一些不合理、不严谨之处
  2. 消除代码不安全之处
  3. 提高编译器效率，增加运行速度
  4. 禁用了ECMAScript的未来版本中可能会定义的一些语法，为新版本的JavaScript做好铺垫

### 22.1 开启严格模式

严格模式可以应用到整个脚本或个别函数中

1. 为脚本开启严格模式：在所有语句之前放一个特定语句 `"use strict"`
2. 为函数开启严格模式：在函数里的第一行写一个特定语句 `"use strict"`

### 22.2 严格模式变化

#### 22.2.1 变量规定

* 在严格模式下不声明无法赋值变量
* 严禁删除已经声明的变量

#### 22.2.2 this指向

* 之前在全局作用域函数中的this指向Windows对象，严格模式下全局作用域中函数的this指向undefined
* 之前构造函数不加new会当普通函数调用，严格模式下必须使用new

#### 22.2.3 函数变化

* 函数不能有重名的参数
* 函数必须声明在顶层。（ES6引入块级作用域）

## 23 正则表达式

正则表达式是用于匹配字符串中字符组合的模式，JavaScript中正则表达式也是对象

### 23.1 特点

* 灵活性、逻辑性和功能性非常强
* 可以迅速地用既简单的方式达到字符串的复杂控制

### 23.2 创建正则表达式

#### 23.2.1 利用RegExp对象来创建

 `var 变量名 = new RegExp(/表达式/)`

#### 23.2.2 利用字面量创建

 `var 变量名=/表达式/`

### 23.3 测试正则表达式

`正则表达式.test(被测试的文本)`

test()正则对象方法，用于检测字符串是否符合该规则

### 23.4 正则表达式中的特殊字符

#### 23.4.1 正则表达式的组成

一个正则表达式可以由简单的字符构成，也可以是简单和特殊字符的组合

特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号

#### 23.4.2 边界符

1. ^：表示匹配行首的文本
2. $：表示匹配行尾的文本
   * `/^abc/`检测到包含以'abc'的内容开头即可
   * `/^abc$/`检测到内容为'abc'才行

#### 23.4.3 字符类

字符类[]表示有一系列字符可供选择，只要匹配其中一个就可以了

1. `/[abc]/`检测到包含'a'或'b'或'c'的内容即可
2. `/^[abc]$/`三选一，只有是a或者是b或者是c这三个字符才返回true
3. 字符组合 `/^[a-zA-Z0-9_]$/`可包含字母数字下划线
4. 字符组合 `/^[^a-zA-Z0-9_]$/`中括号里面有^表示取反

#### 23.4.4 量词符

1. 量词符用来设定某个模式出现的次数
2. *：重复零次或更多次
3. +：重复一次或更多次
4. ?：重复零次或一次
5. {n}：重复n次
6. {n,}：重复n次或更多次
7. {n,m}：重复n到m次

#### 23.4.5 括号总结

1. 中括号：字符集合匹配
2. 大括号：量词符
3. 小括号：表示优先级

#### 23.4.6 预定义类

预定义类值某些常见模式的简写方式

1. \d：匹配0-9之间任一数字
2. \D：匹配所有0-9以外的字符
3. \w：匹配任意的字母、数字和下划线
4. \W：除所有字母、数字和下划线以外的字符
5. \s：匹配空格（包括换行符、制表符、空格符等）
6. \S：匹配非空格的字符

### 23.5 正则替换

replace()方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式

#### 23.5.1 正则表达式参数

`/表达式/[switch]`

* switch也称为修饰符，按照什么模式来匹配
  * g：全局匹配
  * i：忽略大小写
  * gi：全局匹配+忽略大小写
