---
icon: list
date: 2024-07-18
category:
  - 面经
order: 6
excerpt: <p>快手一面</p>
editLink: false
article: false
---
# 快手一面

## 1. 三维模型渲染问题，解决方案

### 1.1 三维静态模型

（异步加载模型、前端放模型和后端传模型）

three.js是以WebGL为基础的库。创建场景=>配置灯光、相机=>导入模型=>设置材质=>渲染

1. 文件本身处理：**gltf格式（gltf和glb）**，**draco压缩**

   **obj（ascii）=>gltf（json+二进制）会输出两种文件类型** ，ascii在内存中以二进制文件储存

- .bin 文件，以**二进制流的方式存储顶点坐标、顶点法线坐标**和贴图纹理坐标、贴图信息等模型基本数据信息；
- .gltf 文件，**本质是 json 文件，记录对bin文件中模型顶点基本数据的索引、材质索引等信息，方便编辑，可读性较好**；

二进制数据，比如3D对象的几何数据和纹理数据通常不被包含在JSON文件中，它们被存储在外部的文件中。**JSON文件中只包含了到这些外部文件的链接**。这使得**二进制数据可以以非常紧凑的形式进行存储**方便互联网传输，并且可以直接被渲染程序使用，**无需额外的解码、预处理**。

**通过 Draco 压缩（blender、gltf-pipeline）基本上是有损的，有两点表现：**

- Draco 通过 Edge breaker 3D 压缩算法**改变了模型的网格数据的索引方法**，缺少了原来的网格顺序；
- Draco 通过**减少顶点坐标、顶点纹理坐标等信息的位数**，以减少数据的存储量。

1. 模型资源往往比较大，数据内容变动不大，可重复利用率不高。频繁请求比较浪费网络资源，加载到本地可以既可以节约请求，充分利用资源，并且可以节省用户下载时间，提高用户体验。区别不大
2. 异步加载模型，three.js的api
3. 文件分块加载（需要将大模型分为小块）
4. 预加载，放到本地indexDB中

- localforage操作。
- 可以直接存储任何 js **数据，包括blob（其实是支持结构化克隆的数据），不像** storage 只能存放字符串
- 把图片或者 3D 模型文件转化成 Blob 格式的文件，存在 IndexedDB 中，就可以解决**免去二次加载时网络请求的时间**。
- 当 3D 需要进行**复杂计算时**，就可以利用 Service Worker 把一些数据存储在 IndexedDB 中或者**通过 Web Worker 读取 IndexedDB 中的数据进行多线程计算。**
- indexdb初始化=>获取连接=>根据请求生成key=>读取/写入数据=>每行加上过期时间=>在axios拦截器中判断有无缓存是否过期。

### 1.2 三维仿真渲染

基于webGL的三维渲染的不足:

**1、前端浏览体验和数据量有很大关系，需要花费大量的数据进行数据的轻量化以及切片处理;**

**2、前端性能的稳定性不高，高负载的情况下容易出现崩溃；**

**3、无法支持大分辨率的场景问题；**

导致问题: 仿真场景渲染等待时间过长,100多秒,不符合实时仿真要求;特别是移动端浏览器性能限制,容易崩溃

解决方案: **三维“云渲染”方案-基于WebRTC的视频流推送技术**,称之为UnityRenderStreaming；

基本原理: 就是将场景通过后端渲染，然后采用实时视频流推送到网页端，并且能够实现前端到后端的交互同步。前端只要声明一个 `<video></video>`标签就可以实现视频流的加载和交互。

通信原理: WebRTC建立点对点连接, 流数据传输需要一条信道，而这个信道则是由信令服务器提供的。这个信令服务器由SignalR实现,此外signalR会根据浏览器支持情况选择websocket,服务器推送,客户端轮询,还引入了断开重连机制.

## 2. 首屏优化

1. 合并文件、压缩文件请求，传输压缩gzip
2. cdn管理静态大文件
3. 图片懒加载
4. 模型异步加载
5. SSR服务器渲染
6. 轻量库，组件尽量不全局引用
7. 鱼骨屏
8. 浏览器缓存

## 3. 隐藏元素

```js
// 两者区别
<div class="img"></div>
.img{
    display:none
    background:url(img.png)  // 照片不会被请求、渲染
}

<img src="img.png"></img>
img{
    display:none // 照片会被请求，不会渲染
}
```

## 4. 定位元素

```js
<div>11111 <span>22222</span></div>
span{
    display:relative // 1111122222 
}
span{
    display:absolute // 1111122222
}
span{
    display:fixed // 1111122222
}
span{
    display:relative // 1111122222
    left:0
}
span{
    display:absolute // 重合，脱离文档流，相对于定位父元素，无则相对于html根元素
    left:0
}
```

## 5. 闭包理解和节流函数

1. 形式：函数返回函数、立即执行函数
2. 作用：防止变量污染（全局变量多了容易冲突=>返回变量的getter和setter=>变量就不会被直接复制修改），变量常驻/泄露
3. 用途：私有库开发、模块化、节流防抖等

```js
function tro(fn,delay){
    let timeout
    return function(){
        if(!timeout){
            timeout = setTimeout(()=>{
                fn()
                timeout = null
            }, delay)
        }
    }
}
```

## 6. 正则-电话号码脱敏

### 6.1 正则基础语法

正常情况下，正则表达式采用**贪婪模式**，即，尽可能多的匹配。

精确个数：

- **用 `\d`可以匹配一个数字**：'00\d'可以匹配'007'，但无法匹配'00A'
- **用 `\w`可以匹配一个字母或数字**：'00\w'可以匹配'007'和'00A'
- **用 `.`可以匹配任意字符**：'00.'可以匹配'007'，'00A'，'00？'

多个字符：

- **用 `\*`表示任意个字符**（包括0个），
- **用 `+`表示至少一个字符**：\s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格
- **[^abc]表示不是字符a或b或c的内容**
- **用 `?`表示0个或1个字符**，
- **用 `{n}`表示n个字符**，
- **用 `{n,m}`表示n-m个字符**：\d{3,8}表示3-8个数字，例如'1234567'

例子：匹配 `'010-12345'`这样的号码呢？由于 `'-'`是特殊字符，在正则表达式中，**要用 `'\'`转义**，所以，上面的正则是 `\d{3}\-\d{3,8}`。

范围匹配：

- `[0-9a-zA-Z\_]`可以匹配一个数字、字母或者下划线；
- `[0-9a-zA-Z\_]+`可以匹配至少由一个数字、字母或者下划线组成的字符串，比如 `'a100'`，`'0_Z'`，`'Py3000'`等等；
- `[a-zA-Z\_][0-9a-zA-Z\_]*`可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；
- `[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}`更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。
- `A|B`可以匹配A或B，所以 `(P|p)ython`可以匹配 `'Python'`或者 `'python'`。
- `^`表示行的开头，`^\d`表示必须以数字开头。
- `$`表示行的结束，`\d$`表示必须以数字结束。

修饰符：g-全文搜索；i-忽略大小写； m-多行搜索；

### 6.2 创建方法

```js
//字面量方式，其由包含在斜杠之间的模式组成，如下所示：
var re = /ab+c/;
//构造函数方式，调用RegExp对象的构造函数，如下所示：
var re = new RegExp("ab+c");
```

### 6.3 使用方法

```js
// 测试字符是否满足正则表达式规则
console.log(/[123]/.test(str))//false

// 正则表达式和 String 对象之间的一个搜索匹配
console.log("abcdefg3sgbh".search(/\d/)) // 7

// 在一个指定字符串中执行一个搜索匹配
console.log(/\d/.exec("abcd456efg")) // 遇到满足条件的就返回,[4]

// 返回一个字符串匹配正则表达式的结果
console.log("abcd456efg".match(/\d/)) // [456]

// 返回一个由替换值（replacement）替换部分或所有的模式（pattern）匹配项后的新字符串。
console.log('a1B2d3X4Z5'.replace(/[a-zA-Z]/,'Q')// Q1Q3Q4Q5 只要匹配到符合规则的就返回
```

### 6.4 应用

#### 1. yyyy-MM-DD转为MM/DD/yyyy类型格式字符串

```js
let text='2022-02-23'
let reg=/(\d{4})-(\d{2})-(\d{2})/
let res=text.replace(reg,'$3/$2/$1')//将yyyy-MM-DD转换为MM/DD/yyyy
console.log(res)
```

#### 2. 电话脱敏

```js
function desensitizeText(text) {
  // 匹配文本中的手机号码，使用正则表达式
  const regex = /1\d{10}/g;
  return text.replace(regex, (match) => {
    // 将匹配到的手机号进行脱敏处理
    return match.replace(/^(\d{3})\d{4}(\d{4})$/, '$1****$2'); // '$1****$2' 是一个替换的模板字符串。其中的 $1 和 $2 分别表示正则表达式中的第一个和第二个分组（即匹配到的3个数字和4个数字），**** 表示替换后的字符串。
  });
}
const text = '这是一段文本内容，其中这个可能是手机号码15298750987，这个可能是个QQ号码98578242，这个可能是个普通的数字1532345322。这可能又是个手机号码 15298750988。';
console.log(desensitizeText(text));
// 输出：这是一段文本内容，其中这个可能是手机号码152****0987，这个可能是个QQ号码98578242，这个可能是个普通的数字1532345322。这可能又是个手机号码 152****0988。
```

## 7. 如何学习前端

## 8. 多人协同更改文件

### 8.1 编辑锁

**当有人在编辑某个文档时，系统会将这个文档锁定，避免其他人同时编辑**

实现：当用户 1 进入某个内容的编辑时，向服务端发送一个请求，服务端校验资源锁定人，为空则将该内容的申请人标记为锁定人1。其他用户访问该内容时，显示锁定人1 正在编辑当前内容而无法编辑，直至锁定人1编辑完毕将该内容解锁。

### 8.2 允许多人编辑，和覆盖

**当用户编辑内容时，如果在编辑的过程中有其他用户提交了新的版本，则页面给出提示发生了版本变更，是否要覆盖**。

实现：用户获取内容时，服务端同时返回该内容的当前版本号。当用户保存时，将**修改后内容和拿到的版本号一并提交**，服务端**校验版本号与数据库中的版本号是否一致：**

- 若一致，表示在该用户编辑的过程中没有版本变更，直接保存成功
- 若**不一致**，表示在该用户编辑的过程中发生了新的版本变更，**保存失败并通知用户，用户可选择是否要进行覆盖**

### 8.3 允许多人编辑，实时协同

例如各种在线文档，几乎都会采用协同编辑的方案，保证多人在线实时编辑。要实现协同编辑，主要需要实现几个关键技术点：

**用于增量传输的 Diff 算法**：在协同编辑领域，常用的两种技术为 **OT**(Operational Transformation) 和 **CRDT** (Conflict-free Replicated Data Type)

**文档的实时更新**：可以采用 **WebSocket** 或者是轮询的方法，在追求性能和体验的情况下，通常我们会选择 WebSocket

**更新内容的富文本编辑器：** 此项是可选的，通常多人在线编辑的场景需要支持丰富的内容编辑，因此需要一个富文本编辑器，普通的文本编辑场景不需要。

其中，**OT** 是多用于协同编辑领域的一种技术，正如其英文全称 Operational Transformation 一样，分为两个步骤：首先是**将用户的编辑行为转换成可枚举的操作**(Operational)；如果是有**多人操作同时进行，则对这些操作进行转换**(Transformation)。

## 9. 如何计算localStorage的大小

### 9.1 计算总容量

不断往 `localStorage`中累加存入 `10KB`（10240字节，str.length==10240），等到超出最大存储时，会报错，那个时候统计出所有累积的大小，就是总存储量了！

```js
let str = '0123456789'
let temp = ''
// 先做一个 10KB 的字符串
while (str.length !== 10240) {
  str = str + '0123456789'
}

// 先清空
localStorage.clear()

const computedTotal = () => {
  return new Promise((resolve) => {
    // 不断往 LocalStorage 中累积存储 10KB
    const timer = setInterval(() => {
      try {
        localStorage.setItem('temp', temp)
      } catch {
        // 报错说明超出最大存储
        resolve(temp.length / 1024 - 10)
        clearInterval(timer)
        // 统计完记得清空
        localStorage.clear()
      }
      temp += str
    }, 0)
  })
}

(async () => {
  const total = await computedTotal()
  console.log(`最大容量${total}KB`)
})()
```

### 9.2 已用容量

即计算所有键值对所占空间。通过JSON.stringify将值转换为字符串，获取字符串长度，单位为字节

```js
function getLocalStorageSize() {
  let total = 0;
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    const value = localStorage.getItem(key);
    total += key.length + value.length;
  }
  return total;
}
console.log(getLocalStorageSize());
```
