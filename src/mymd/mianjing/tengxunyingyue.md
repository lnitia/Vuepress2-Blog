---
icon: list
date: 2024-08-15
category:
  - 面经
order: 8
excerpt: <p>腾讯音乐一面</p>
editLink: false
article: false
---
# 腾讯音乐一面

## 1 自我介绍

## 2 针对青岛项目展开讲讲

## 3 unity画面展示会不会有性能问题，有没有遇到渲染比较慢或卡顿问题，实时传输为什么没有卡顿呢

Unity Render Streaming 在网页端展示时确实可能遇到性能问题，特别是在以下场景中：

* **网络带宽不足** ：视频流的传输依赖网络带宽，如果带宽不足，可能导致画面延迟、卡顿。
* **客户端性能** ：客户端设备的性能较低时，解码视频流可能会较慢，导致画面不流畅。
* **服务器负载** ：如果多个用户同时连接同一个 Unity Render Streaming 服务器，服务器的负载过高，也可能导致流传输变慢。

**实时传输没有卡顿**的原因通常与以下因素有关：

* **WebRTC 技术** ：Unity Render Streaming 基于 WebRTC 协议进行实时视频流传输，WebRTC 通过直接的点对点连接减少了延迟。
* **视频编码优化** ：使用 H.264 等高效视频编码格式，压缩传输的数据量，减少传输延迟。

不过，在低带宽或高延迟网络环境下，仍可能出现渲染慢或卡顿问题。

## 4 有没有页面方面的性能问题，比如整个页面打开会比较慢

1. 接收unity画面前会有几秒-十几秒钟的延迟，通过loading界面进行过渡
2. 三维模型展示会延迟两秒左右，通过修改模型格式为二进制的glft格式进行优化，并将模型blob格式存到indexedDB中

在大型项目中，页面性能问题可能会包括以下几种：

* **初次加载时间较长** ：页面资源（如 JS、CSS、图片等）较大，导致页面打开速度慢。
* **渲染阻塞** ：JavaScript 脚本或 CSS 文件的加载可能会阻塞页面的渲染。
* **资源请求数量过多** ：过多的 HTTP 请求会增加页面加载时间，尤其是在带宽有限的情况下。

为了解决这些问题，可以使用代码拆分、延迟加载资源（如懒加载图片）以及优化资源的大小和数量。

## 5 讲一下react怎么做双向数据绑定的

React 不是默认双向数据绑定框架，通常是单向数据流

umi框架的数据管理采用的是umi提供的一个插件。

一种基于 `hooks` 范式的简易数据管理方案（部分场景可以取代 `dva`），通常用于中台项目的全局共享数据。

它约定在src/model文件夹中的文件为model文件。每个文件需要默认导出一个 function，该 function 定义了一个 Hook。就是自定义 `hooks` 模块。

 `@umijs/plugin-model` 把自定义hook里的状态变成了『全局状态』，多个组件中使用该 `model`文件 时，拿到的同一份状态。从而实现全局数据的管理。

* **基于 `React.Context` 创建一个全局的 `Context`**;
* **使用 `Context.Provider` 包裹根组件，并执行所有的 `useModel` 对应的 `hooks`**
* **在 `useModel` 函数中通过 `useContext` 获取到 `dispatcher`, 并更新数据**

## 6 有没有引入redux

没有

Redux 是 React 生态中常用的状态管理库，用于在全局范围内管理应用的状态。它通过 `store` 保存状态，`action` 触发状态改变，`reducer` 负责状态更新。

## 7 讲一下周报系统

## 8 网络请求是怎么走通的，是用的http还是https，为什么没有引入https

* **HTTP** 是一种无状态的协议，常用于简单的网络请求。
* **HTTPS** 是 HTTP 的加密版本，通过 SSL/TLS 协议加密数据传输，防止数据被中间人攻击或窃听。

没有引入 HTTPS 的原因包括：

* **项目需求** ：对于一些内网项目或对安全性要求较低的场景，可能没有引入 HTTPS。
* **配置复杂度** ：启用 HTTPS 需要服务器配置 SSL/TLS 证书，可能增加了项目的复杂性。

## 9 http连接的三次握手四次挥手

**三次握手** ：建立连接的过程，确保客户端和服务器都准备好进行数据传输。

1. 客户端发送 SYN 包（请求建立连接）
2. 服务器回复 SYN-ACK 包（同意建立连接）
3. 客户端发送 ACK 包（确认连接建立）

**四次挥手** ：关闭连接的过程，确保双方都完成数据传输。

1. 客户端发送 FIN 包（请求关闭连接）
2. 服务器回复 ACK 包（确认关闭请求）
3. 服务器发送 FIN 包（请求关闭连接）
4. 客户端发送 ACK 包（确认关闭）

## 10 http相对于https有什么问题

* **数据传输不安全** ：HTTP 数据是明文传输，容易被中间人窃听或篡改。
* **无法验证身份** ：HTTP 无法确认服务器的真实性，容易遭受钓鱼攻击。

## 11 https是怎么加密的

HTTPS 通过 SSL/TLS 协议进行加密，主要包括以下步骤：

1. **握手阶段** ：客户端和服务器协商加密算法和会话密钥。
2. **公钥加密** ：客户端使用服务器的公钥加密数据，只有服务器的私钥能解密。
3. **对称加密** ：使用协商好的对称密钥加密通信内容。

## 12 有没有了解请求报文和响应报文的内容

**请求报文** ：

* 请求行：包含请求方法（GET、POST 等）、请求路径和协议版本。
* 请求头：包含请求的元数据，如 `User-Agent`、`Host`、`Accept` 等。
* 请求体：包含提交的数据（POST 请求时）。

**响应报文** ：

* 状态行：包含协议版本、状态码和状态描述。
* 响应头：包含响应的元数据，如 `Content-Type`、`Content-Length`、`Set-Cookie` 等。
* 响应体：包含实际返回的数据。

## 13 浏览器从输入url到显示界面的过程，渲染部分展开讲讲

* **读缓存**
* **DNS 解析** ：将域名解析为 IP 地址。
* **建立连接** ：通过 TCP/IP 协议建立与服务器的连接。
* **发送请求** ：浏览器向服务器发送 HTTP/HTTPS 请求。
* **服务器处理请求** ：服务器处理请求并返回响应数据。
* **浏览器接收响应** ：浏览器接收并解析 HTML、CSS、JavaScript 等资源。
* **页面渲染** ：浏览器将解析的内容构建 DOM 树、CSSOM 树，然后生成渲染树，最后绘制页面。

## 14 假如把js脚本放在html最前面加载会有什么问题，对页面性能方面有什么影响

将 JS 脚本放在 HTML 头部可能导致以下问题：

* **阻塞渲染** ：浏览器在加载和解析 JS 时，会阻塞 DOM 树的构建，导致页面渲染延迟。
* **页面加载时间增加** ：页面内容在 JS 加载完成前不会显示，用户体验变差。

通常建议将 JS 脚本放在页面底部，或者使用 `defer` 和 `async` 属性进行优化。

## 15 有些业务必须在dom元素渲染前加载js脚本，有什么解决方法吗

如果业务必须在 DOM 元素渲染前加载 JS 脚本，可以使用以下方法：

1.  `<script>` **标签的** `async` **或** `defer` **属性** ：

* `async`：异步加载脚本，加载完立即执行，不阻塞页面渲染。
* `defer`：延迟执行脚本，等 DOM 解析完成后执行，不阻塞页面渲染。

2. **将关键的初始化代码内嵌在 HTML 中** ，确保最小的 JS 逻辑在页面加载初期就能执行。

## 16 服务端渲染的利弊，什么时候服务端渲染久一点，什么时候服务端渲染快一点，不是所有场景都能使用服务端渲染的，能举例吗

**优点** ：

* **SEO 友好** ：搜索引擎可以抓取完整的 HTML 内容。
* **首屏加载快** ：HTML 内容在服务器端渲染，浏览器直接接收和渲染，减少客户端渲染的时间。

**缺点** ：

* **服务器负载高** ：每次请求都需要服务器生成完整的页面，增加服务器压力。
* **交互性差** ：页面需要更多的 JS 逻辑来处理用户交互，可能需要额外的客户端渲染。

 **使用场景** ：

* **服务端渲染适用场景** ：内容需要快速展示，且对 SEO 友好，如博客、新闻网站。
* **客户端渲染适用场景** ：交互性强的单页应用，如仪表盘、管理后台。

## 17 讲一下防抖和节流，使用场景

* **防抖（Debounce）** ：在事件触发后，只有在规定的时间内没有再次触发事件，才会执行一次处理函数。适用于输入框实时搜索等场景。
* **节流（Throttle）** ：在规定的时间内，事件触发后只能执行一次处理函数，适用于窗口缩放、滚动事件等高频触发的场景。

## 18 this指向绑定的规则，箭头函数的this指向

* **默认绑定** ：函数独立调用时，`this` 指向全局对象（严格模式下为 `undefined`）。
* **隐式绑定** ：函数作为对象的方法调用时，`this` 指向该对象。
* **显式绑定** ：通过 `call`、`apply`、`bind` 明确指定 `this` 指向。
* **new 绑定** ：通过 `new` 关键字创建实例时，`this` 指向新创建的对象。

 **箭头函数的 `this` 指向** ：箭头函数没有自己的 `this`，它的 `this` 继承自外层作用域。

## 19 js为什么是单线程的

JavaScript 设计为单线程是因为它最初是作为浏览器中的脚本语言，用于处理用户交互和更新 DOM。如果是多线程，可能会导致多个线程同时修改 DOM，造成不可预期的结果。为了避免这种情况，JavaScript 选择了单线程模型，但通过事件循环和回调机制来处理异步操作

## 20 反问

技术栈：

腾讯内部的跨端框架，基于react
